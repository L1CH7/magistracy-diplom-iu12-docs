\section{Реализация подсистемы межсервисного взаимодействия}

Подсистема межсервисного взаимодействия (API Gateway) выполняет роль единой точки входа для всех внешних клиентов, обеспечивая маршрутизацию запросов, балансировку нагрузки и сокрытие внутренней топологии микросервисов \cite{nurkaev2023api, medvedev2021microservices}.

\subsection{Унификация доступа и декларативная маршрутизация}

В микросервисной архитектуре клиентское приложение вынуждено знать адреса десятков внутренних сервисов (Data Processor, Router, Postgres и т.д.). При изменении адресации, масштабировании или репликации требуется обновление всех клиентов. А жесткое кодирование маршрутов в коде самого шлюза также приводит к высокой связности: добавление нового сервиса требует пересборки и перезапуска Gateway.

Для решения данной задачи внедрен паттерн <<Реестр маршрутов>> \cite{pozdnyakov2023routing}. Конфигурация всех проксируемых путей вынесена в внешний YAML-файл, который загружается при старте приложения.
Пример конфигурации:
\begin{code}{gateway-routes-yaml}{YAML}{Пример конфигурации реестра маршрутов}
routes:
  - path: /api/v1/map
    service: http://data-processor:8000
    strip_prefix: false
  - path: /api/v1/route
    service: http://router-service:8001
    methods: [POST]
\end{code}

При запуске шлюз читает реестр и динамически генерирует обработчики для каждого маршрута.

Благодаря этому клиент взаимодействует только с одним хостом, не зная о внутренней сложности системы. Изменение топологии бэкенда производится правкой конфигурационного файла без остановки сервиса. Применение паттернов прокси и фасад \cite{ochuba2025api} позволяет также реализовать централизованную аутентификацию и ограничение скорости запросов \cite{matias2024microservices}.

\subsection{Проблема захвата переменной цикла}

В процессе реализации динамической регистрации маршрутов в цикле \texttt{for} была выявлена ошибка, связанная с особенностями работы замыканий в Python \cite{codeql2024closure}.
Рассмотрим наивную реализацию:
\begin{code}{naive-loop-error}{Python}{Ошибочная реализация регистрации обработчиков}
for route in routes:
    # ОШИБКА: route берется из внешней области видимости
    app.add_route(route.path, lambda req: proxy(req, route.url))
\end{code}

По завершении цикла переменная \texttt{route} принимает значение последнего элемента списка. В результате все зарегистрированные эндпоинты (например, \texttt{/map} и \texttt{/route}) начинали перенаправлять запросы на один и тот же последний сервис.

Это обусловлено фундаментальной особенностью работы замыканий в Python: разрешение переменных происходит в момент фактического вызова функции, а не при её создании. Поскольку к моменту поступления первого HTTP-запроса цикл инициализации уже завершен, все созданные лямбда-функции обращаются к текущему состоянию переменной \texttt{route}, которая к этому времени содержит ссылку на последний объект списка.

Для решения этой особенности был применен паттерн <<Фабрика замыканий>>. Создана отдельная функция высшего порядка, которая принимает текущее значение переменной как аргумент и возвращает новую асинхронную функцию-обработчик. Это создает изолированную область видимости для каждой итерации цикла.

\begin{code}{closure-factory}{Python}{Фабрика замыканий для динамических маршрутов}
def create_proxy_handler(target_url: str):
    # target_url "заморожен" в локальной области видимости этой функции
    async def handler(request: Request):
        return await forward_request(request, target_url)
    return handler

for route in registry:
    handler = create_proxy_handler(route.service_url)
    app.add_route(route.path, handler)
\end{code}

Применение фабрики замыканий гарантировало корректную маршрутизацию запросов. Этот подход является идиоматическим для Python и устраняет риск появления скрытых программных ошибок при динамическом связывании функций.

\subsection{Туннелирование WebSocket-соединений}

Протокол HTTP функционирует без сохранения состояния, тогда как WebSocket требует поддержания постоянного TCP-соединения. Использование метода опроса по HTTP (HTTP polling) создает избыточную нагрузку на сеть и задержки \cite{websocket2024comparison, barber2018polling}. Стандартные библиотеки проксирования (например, \texttt{httpx}) не поддерживают модернизацию протокола HTTP-соединения до WebSocket.

В рамках работы разработан механизм асинхронного туннелирования на базе библиотеки \texttt{websockets} и примитивов конкурентности \texttt{asyncio}.
При установке соединения Шлюз выступает в роли прозрачного прокси:
\begin{itemize}
    \item принимает \texttt{Sec-WebSocket-Key} от клиента;
    \item инициирует рукопожатие с целевым микросервисом;
    \item запускает две независимые корутины для пересылки сообщений.
\end{itemize}

Для управления жизненным циклом соединения используется функция \texttt{asyncio.gather}, которая ожидает завершения любой из двух задач пересылки:

\begin{code}{asyncio-tunnel}{Python}{Асинхронное управление задачами туннелирования}
upstream_task = asyncio.create_task(proxy_stream(client_ws, upstream_ws))
downstream_task = asyncio.create_task(proxy_stream(upstream_ws, client_ws))
# Ожидание разрыва соединения с любой стороны
done, pending = await asyncio.wait(
    [upstream_task, downstream_task],
    return_when=asyncio.FIRST_COMPLETED
)
# Отмена оставшейся задачи
for task in pending: task.cancel()
\end{code}

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.8\textheight, keepaspectratio]{03-gateway-seq}
    \caption{Диаграмма последовательности проксирования WebSocket}
    \label{fig:gateway-seq}
\end{figure}

На рисунке \ref{fig:gateway-seq} представлен процесс обмена сообщениями.
Реализованный протокол поддерживает три типа событий.

\begin{enumerate}
    \item Событие \textbf{Heartbeat} -- регулярные сообщения \texttt{ping/pong} для поддержания активности соединения и предотвращения разрыва по таймауту.
    \item Событие \textbf{Broadcast} -- оповещения от сервиса Data Processor (\texttt{tiles\_invalidated}, \texttt{ways\_updated}), которые шлюз мультиплексирует на всех активных клиентов (из \texttt{websocket.py}).
    \item Событие \textbf{Config} -- передача настроек клиенту при инициализации сессии.
\end{enumerate}

Шлюз декодирует заголовки сообщений для маршрутизации, но тело бинарных пакетов (MVT) передает без изменений.

Реализованный туннель позволяет строить событийно-ориентированные системы, где сервер может инициировать отправку данных клиенту. Использование асинхронного ввода-вывода позволяет одному экземпляру шлюза обслуживать тысячи активных WebSocket-сессий с потреблением памяти менее 10~КБ на соединение.
