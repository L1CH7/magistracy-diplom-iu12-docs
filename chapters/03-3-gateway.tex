\section{Реализация подсистемы межсервисного взаимодействия (Шлюз)}

Подсистема межсервисного взаимодействия (API Gateway) выполняет роль единой точки входа для всех внешних клиентов, обеспечивая маршрутизацию запросов, балансировку нагрузки и сокрытие внутренней топологии микросервисов.

\subsection{Унификация доступа и декларативная маршрутизация}

В микросервисной архитектуре клиентское приложение вынуждено знать адреса десятков внутренних сервисов (Data Processor, Router, Auth Service и т.д.). При изменении адресации или масштабировании (добавлении реплик) требуется обновление всех клиентов. Жесткое кодирование (hardcode) маршрутов в коде самого шлюза также приводит к высокой связности: добавление нового сервиса требует пересборки и перезапуска Gateway.

Для решения данной задачи внедрен паттерн «Реестр маршрутов» (Route Registry). Конфигурация всех проксируемых путей вынесена в внешний YAML-файл, который загружается при старте приложения.
Пример конфигурации:
\begin{code}{gateway-routes-yaml}{YAML}{Пример конфигурации реестра маршрутов}
routes:
  - path: /api/v1/map
    service: http://data-processor:8000
    strip_prefix: false
  - path: /api/v1/route
    service: http://router-service:8001
    methods: [POST]
\end{code}

При запуске Шлюз читает реестр и динамически генерирует обработчики (Handlers) для каждого маршрута.

Благодаря этому клиент взаимодействует только с одним хостом (\texttt{api.gateway.local}), не зная о внутренней сложности системы. Изменение топологии бэкенда производится правкой конфигурационного файла без остановки сервиса (при наличии механизма Hot Reload).

\subsection{Проблема захвата переменной цикла (Loop Variable Capture)}

В процессе реализации динамической регистрации маршрутов в цикле \texttt{for} была выявлена ошибка, связанная с особенностями работы замыканий в Python (Late Binding).
Рассмотрим наивную реализацию:
\begin{code}{naive-loop-error}{Python}{Ошибочная реализация регистрации обработчиков}
for route in routes:
    # ОШИБКА: route берется из внешней области видимости
    app.add_route(route.path, lambda req: proxy(req, route.url))
\end{code}

По завершении цикла переменная \texttt{route} принимает значение последнего элемента списка. В результате все зарегистрированные эндпоинты (например, \texttt{/map} и \texttt{/route}) начинали перенаправлять запросы на один и тот же последний сервис.

Для фиксации контекста выполнения применен паттерн «Фабрика замыканий» (Closure Factory). Создана отдельная функция высшего порядка, которая принимает текущее значение переменной как аргумент и возвращает новую асинхронную функцию-обработчик. Это создает изолированную область видимости (Closure Scope) для каждой итерации цикла.

\begin{code}{closure-factory}{Python}{Фабрика замыканий для динамических маршрутов}
def create_proxy_handler(target_url: str):
    # target_url "заморожен" в локальной области видимости этой функции
    async def handler(request: Request):
        return await forward_request(request, target_url)
    return handler

for route in registry:
    handler = create_proxy_handler(route.service_url)
    app.add_route(route.path, handler)
\end{code}

Применение фабрики замыканий гарантировало корректную маршрутизацию запросов. Этот подход является идиоматическим для Python и устраняет риск возникновения трудноуловимых багов при динамическом маппинге функций.

\subsection{Туннелирование WebSocket-соединений}

Протокол HTTP является stateless (без сохранения состояния), тогда как WebSocket требует поддержания постоянного TCP-соединения. Стандартные библиотеки проксирования (например, \texttt{httpx}) не умеют «пробрасывать» (Upgrade) HTTP-соединение до WebSocket и прозрачно передавать бинарный поток данных в обе стороны.

В рамках работы разработан механизм асинхронного туннелирования на базе библиотеки \texttt{websockets} и примитивов конкурентности \texttt{asyncio}.
При установке соединения Шлюз выступает в роли «человека посередине» (Man-in-the-Middle):
\begin{itemize}
    \item Принимает \texttt{Sec-WebSocket-Key} от клиента.
    \item Инициирует рукопожатие с целевым микросервисом.
    \item Запускает две независимые корутины для пересылки сообщений.
\end{itemize}

Для управления жизненным циклом соединения используется функция \texttt{asyncio.gather}, которая ожидает завершения любой из двух задач пересылки:
\begin{code}{asyncio-tunnel}{Python}{Асинхронное управление задачами туннелирования}
upstream_task = asyncio.create_task(proxy_stream(client_ws, upstream_ws))
downstream_task = asyncio.create_task(proxy_stream(upstream_ws, client_ws))
# Ожидание разрыва соединения с любой стороны
done, pending = await asyncio.wait(
    [upstream_task, downstream_task],
    return_when=asyncio.FIRST_COMPLETED
)
# Отмена оставшейся задачи
for task in pending: task.cancel()
\end{code}

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.6\textheight, keepaspectratio]{03-gateway-seq}
    \caption{Диаграмма последовательности проксирования WebSocket}
    \label{fig:gateway-seq}
\end{figure}

На рисунке \ref{fig:gateway-seq} показана последовательность обмена сообщениями. Шлюз прозрачно транслирует коды закрытия (Close Codes) и бинарные фреймы, не вмешиваясь в содержимое пакетов.

Реализованный туннель позволяет строить событийно-ориентированные системы (Event-Driven), где сервер может инициировать отправку данных (Push Notifications) клиенту. Использование асинхронного I/O позволяет одному экземпляру шлюза обслуживать тысячи активных WebSocket-сессий с потреблением памяти менее 10 КБ на соединение.
