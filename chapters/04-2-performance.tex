\section{Анализ производительности и масштабируемости}

\subsection{Анализ конкурентного доступа (Парадокс масштабируемости)}

В ходе нагрузочного тестирования был проведен эксперимент по обработке фиксированного пула из 1000 запросов на построение маршрута.
В последовательном режиме (1 клиент) общее время обработки составило \textbf{6243 секунды}.
При распараллеливании на 16 конкурентных клиентов (соответствует числу логических ядер компьютреа) время сократилось до \textbf{1201 секунды}.
Достигнутое ускорение в $\approx5.2$ раза доказывает, что система не блокируется при чтении, демонстрируя высокую пропускную способность.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, keepaspectratio]{04-mvcc-seq}
    \caption{Диаграмма последовательности обработки конкурентных запросов}
    \label{fig:mvcc-seq}
\end{figure}

На диаграмме (рис. \ref{fig:mvcc-seq}) по оси времени вертикально отображен поток управления. Видно, что Python-сервис (FastAPI) использует асинхронный I/O (ключевое слово \texttt{await}), передавая управление планировщику задач сразу после отправки запроса в БД.

Ключевым фактором ускорения является архитектура СУБД PostgreSQL. Согласно статье \cite{postolenko2025_complexities}, каждому подключению выделяется отдельный бэкенд-процесс. Благодаря механизму изоляции снимков, читающие транзакции не блокируют друг друга \cite{postgrespro_mvcc_intro}, что позволяет выполнять тяжелые выборки данных физически параллельно на разных ядрах процессора.

\subsection{Регрессионный анализ сложности}

На рисунке \ref{fig:latency-regression} по оси абсцисс отложен интегральный показатель сложности ($N \cdot K$, где $N$ -- число узлов в графе поиска, $K$ -- число запрашиваемых альтернатив), по оси ординат -- время выполнения запроса в секундах.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{assets/images/latency_regression}
    \caption{Регрессионный анализ зависимости времени отклика от сложности запроса}
    \label{fig:latency-regression}
\end{figure}

График демонстрирует выраженную линейную зависимость времени выполнения от сложности запроса. Отсутствие экспоненциального роста подтверждает, что примененный механизм динамического ограничения области поиска эффективно отсекает лишние вершины графа. Это позволяет сохранять алгоритмическую сложность близкой к линейной $O(N)$ даже при увеличении географической протяженности маршрута.

\subsection{Многофакторный анализ пропускной способности}

Рисунок \ref{fig:throughput-complexity} представляет собой 3D-поверхность зависимости времени отклика (ось Z) от двух факторов: длины маршрута (ось X) и количества запрашиваемых альтернатив (ось Y).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{assets/images/throughput_complexity_3d}
    \caption{3D-поверхность зависимости времени отклика от количества точек маршрута и числа альтернатив}
    \label{fig:throughput-complexity}
\end{figure}

Плоскость графика показывает, что время отклика равномерно растет как от количества точек маршрута $N$, так и от числа альтернатив $K$. Отсутствие резких скачков («стен») на поверхности графика свидетельствует о стабильности алгоритма распределения памяти в СУБД PostgreSQL: увеличение числа альтернатив $K$ приводит к предсказуемому линейному росту времени без деградации производительности системы.
