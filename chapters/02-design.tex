\chapter{Конструкторский раздел}
\label{ch:design}

\section{Проектирование структуры дорожного графа}

\subsection{Проблема масштабирования при построении топологии}

При проектировании подсистемы построения графа была выявлена критическая проблема масштабируемости стандартных инструментов библиотеки \texttt{pgRouting}. Функция \texttt{pgr\_nodeNetwork}, предназначенная для создания топологии (поиска пересечений и создания узлов), функционирует по принципу полной загрузки графа в оперативную память.

При переходе от тестового графа (район Хамовники, $\approx$ 5000 ребер) к полному графу Московской агломерации (более 250 000 ребер) процесс сборки аварийно завершался по причине исчерпания оперативной памяти (OOM --- Out Of Memory).

Анализ потребления ресурсов при использовании стандартного подхода приведен в таблице~\ref{tab:oom-metrics}.

\begin{table}[H]
    \centering
    \caption{Потребление ресурсов при сборке графа (Legacy подход)}
    \label{tab:oom-metrics}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Метрика} & \textbf{Значение} & \textbf{Источник данных} \\ \hline
        Потребление RAM & $> 12$ ГБ & \texttt{docker stats} (пик перед падением) \\ \hline
        Время до падения & $\approx 2$ часа & Логи контейнера \\ \hline
        Доступная RAM & 16 ГБ & Аппаратное ограничение сервера \\ \hline
        Результат & Crash (Exit Code 137) & Kernel OOM Killer \\ \hline
    \end{tabular}
\end{table}

Профилирование показало, что узким местом являются длинные магистрали (МКАД, ТТК, вылетные шоссе). В исходных данных OpenStreetMap (OSM) они часто представлены одной геометрией длиной 8--15 км. При попытке построить матрицу пересечений для ребра такой длины алгоритм сталкивается с комбинаторным взрывом, так как каждое потенциальное пересечение требует вычисления геометрического пересечения с сотнями соседних объектов.

\subsection{Реализация алгоритма Grid Partitioning}

Для решения проблемы исчерпания памяти был разработан и внедрен алгоритм \textbf{Grid Partitioning} (плиточная нарезка). Вместо обработки всего графа целиком, карта разбивается на независимые квадратные тайлы размером $0.05^\circ \times 0.05^\circ$ (примерно $3 \times 5$ км в проекции Москвы).

Этапы обработки тайла включают:
\begin{enumerate}
    \item \textbf{Фильтрация (BBOX):} Выборка ребер, попадающих в границы текущего тайла.
    \item \textbf{Физическая нарезка (\texttt{ST\_Subdivide}):} Разрезание длинных геометрий на сегменты длиной не более 500 метров. Это гарантирует разбиение длинных магистралей на управляемые фрагменты.
    \item \textbf{Локальная топология:} Запуск \texttt{pgr\_nodeNetwork} исключительно для ребер внутри тайла (выполняется в памяти изолированного процесса).
    \item \textbf{Снэппинг (\texttt{ST\_SnapToGrid}):} Привязка координат к сетке $0.000001^\circ$ для устранения погрешностей плавающей запятой на границах тайлов.
    \item \textbf{Атомарная вставка:} Пакетная вставка (Bulk Insert) обработанных сегментов в целевую таблицу \texttt{graphs.edges}.
\end{enumerate}

Схема алгоритма представлена на рисунке~\ref{fig:grid-algo}.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.4\textheight, keepaspectratio]{02-grid-algo}
    \caption{Схема алгоритма Grid Partitioning}
    \label{fig:grid-algo}
\end{figure}

Внедрение данного алгоритма позволило сократить потребление оперативной памяти до 370 МБ и время сборки до 13 минут, обеспечив стабильность процесса построения графа.

\subsection{Контроль качества и связности графа}

Одной из проблем автоматической генерации графа из данных OSM является появление изолированных <<островов>> (Islands) --- участков дорог, не связанных с основной сетью (например, закрытые территории или ошибки оцифровки). Для валидации графа используется анализ компонент связности с помощью функции \texttt{pgr\_connectedComponents}.

Результаты анализа связности дорожной сети Москвы представлены на рисунке~\ref{fig:components-map}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{components_map}
    \caption{Визуализация связности дорожной сети (черным --- основная компонента, красным --- изолированные острова)}
    \label{fig:components-map}
\end{figure}

Анализ показал, что основная компонента (Main Component) содержит 98.4\% всех ребер (240 234 из 244 305), что свидетельствует о высокой связности дорожной сети.

\section{Проектирование схемы данных}

Подсистема данных (Data Processor) отвечает за поддержание актуальной копии дорожной сети. Загрузка данных OSM осуществляется через Overpass API с использованием алгоритма параллельной плиточной загрузки для обхода ограничений API.

Данные хранятся в реляционной схеме, оптимизированной для маршрутизации и генерации векторных тайлов (рисунок~\ref{fig:er-schema}).

\begin{figure}[H]
    \centering
    \includemermaid[height=0.4\textheight]{02-er-schema}
    \caption{ER-диаграмма схемы данных (OSM vs GRAPHS)}
    \label{fig:er-schema}
\end{figure}

Таблица \texttt{osm.ways} содержит поле \texttt{geom\_3857} (Geometry в проекции Web Mercator), которое вычисляется один раз при вставке. Это увеличивает размер таблицы на 30\%, но снижает нагрузку на процессор при генерации тайлов, исключая необходимость трансформации координат в момент запроса (On-Demand Generation).

\section{Алгоритмическое обеспечение маршрутизации}

\subsection{Выбор алгоритма поиска пути}

В ходе проектирования были рассмотрены различные алгоритмы поиска пути. Первоначально планировалось использовать алгоритм \textbf{A* (A-Star)}, однако его реализация в базе данных (\texttt{pgr\_astar}) показала низкую производительность из-за необходимости выполнения множественных неявных операций JOIN для получения координат узлов при вычислении эвристики. Время поиска маршрута на дистанции 30 км составляло 47 секунд.

В качестве итогового решения был выбран алгоритм \textbf{Dijkstra} в сочетании с методом итеративных штрафов (Iterative Penalty) для поиска альтернативных маршрутов (K-Routes).

Алгоритм работает следующим образом:
\begin{enumerate}
    \item Ищется кратчайший путь с использованием стандартного алгоритма Дейкстры.
    \item Стоимость (\texttt{cost}) всех ребер, входящих в найденный путь, увеличивается в 5.0 раз. Коэффициент подобран экспериментально для обеспечения значимого отличия альтернативного маршрута.
    \item Поиск запускается повторно на графе с обновленными весами.
    \item Процесс повторяется $K$ раз.
\end{enumerate}

Реализация осуществляется через динамическую модификацию весов в SQL-запросе с использованием конструкции \texttt{CASE}, что не требует изменения данных на диске.

\subsection{Оптимизация: Dynamic Bounding Box}

Поиск пути по полному графу Москвы является избыточным. Для оптимизации применяется ограничение зоны поиска (Bounding Box). Размер буфера рассчитывается динамически по формуле:

\begin{equation}
    BBOX = Envelope(Start, End) + Buffer
\label{eq:bbox}
\end{equation}
\begin{equation}
    Buffer = \max(0.015^\circ, Distance(Start, End) \times 0.3)
\label{eq:buffer}
\end{equation}

Коэффициент 0.3 обеспечивает достаточный запас для поиска объездных путей, отсекая при этом 80--90\% графа. Пространственный индекс GiST позволяет мгновенно фильтровать ребра, попадающие в расчетную область. Применение данной оптимизации позволило сократить время поиска маршрута длиной 30 км с 47.8 с до 8.4 с (ускорение в 5.7 раза).

\subsection{Привязка координат (Vertex Snapping)}

Привязка GPS-координат к графу осуществляется не к ближайшему ребру, а к ближайшему \textbf{узлу} (Vertex Snapping) с использованием оператора KNN (\texttt{<->}). Это предотвращает некорректную привязку к туннелям или эстакадам, проходящим рядом с точкой, но не имеющим съездов, так как узлы графа существуют только в местах реальных пересечений.

\section{Проектирование подсистемы визуализации}

Визуализация карты строится на технологии векторных тайлов (MVT). Выбран архитектурный подход, при котором тайлы формируются SQL-запросом \texttt{ST\_AsMVT} в момент обращения (On-Demand Generation). Это позволяет реализовать динамический уровень детализации (LOD), изменяя состав объектов в тайле в зависимости от масштаба отображения, без необходимости перегенерации кэша.
