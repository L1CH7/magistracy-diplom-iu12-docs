\chapter{Математическое и алгоритмическое обеспечение системы}

\section{Математическая модель дорожной сети}

В основе навигационной системы лежит представление дорожной сети в виде взвешенного ориентированного графа $G = (V, E)$, где $V$ — множество вершин, соответствующих перекресткам и тупикам, а $E$ — множество ребер, представляющих участки дорог. Каждое ребро $e_{ij} \in E$, соединяющее вершины $v_i$ и $v_j$, характеризуется весовой функцией $w(e_{ij}, \tau)$, зависящей от времени $\tau$.

Целевая функция поиска оптимального маршрута $P^*$ формулируется как минимизация суммарной стоимости прохождения ребер маршрута\cite{dijkstra1959_yale}:
\begin{equation}
P^* = \arg \min_{P \in \mathcal{P}_{st}} \sum_{e \in P} w(e, \tau)
\end{equation}
где $\mathcal{P}_{st}$ — множество всех допустимых путей из точки $s$ в точку $t$.

Весовая функция ребра $w(e)$ является композицией статических и динамических параметров:
\begin{equation}
w(e) = \left( \frac{L_e}{v_{max} \cdot \eta_{type}} \right) \cdot K_{penalty}
\end{equation}
где:
\begin{itemize}
    \item $L_e$ — физическая длина участка дороги (в метрах);
    \item $v_{max}$ — максимально допустимая скорость на участке (км/ч);
    \item $\eta_{type}$ — коэффициент типа дорожного покрытия (например, $1.0$ для асфальта, $0.6$ для грунтовой дороги);
    \item $K_{penalty}$ — динамический коэффициент штрафа (например, при наличии пробок или временных ограничений).
\end{itemize}

Данная модель позволяет унифицировать критерии оптимизации, сводя задачу поиска наиболее быстрого, короткого или экономичного пути к варьированию коэффициентов весовой функции\cite{wiki_dijkstra_ru}.

\section{Плиточная декомпозиция графа для оптимизации ресурсов}

\subsection{Проблема исчерпания ресурсов при построении топологии}
Одной из ключевых технических проблем при обработке графа Московской агломерации (более 250 000 ребер) стало исчерпание оперативной памяти (Out Of Memory) при выполнении стандартной процедуры построения топологии \texttt{pgr\_nodeNetwork}. Данная функция пытается загрузить всю геометрию в память для поиска пересечений, что приводило к потреблению более 12 ГБ ОЗУ и аварийному завершению процесса (Exit Code 137). 

Анализ исходных данных выявил наличие сверхдлинных ребер (например, участки МКАД длиной до 8373 м), которые создавали «комбинаторный взрыв» при вычислении пересечений с локальной дорожной сетью.

\subsection{Алгоритм пространственного секционирования}
Для решения проблемы был разработан алгоритм пространственного секционирования графа (Grid Partitioning). Метод заключается в декомпозиции исходной области карты на независимые квадратные наборы (тайлы) фиксированного размера.

Процесс обработки включает следующие этапы:
\begin{enumerate}
    \item \textbf{Секционирование.} Вся область карты разбивается на тайлы размером $0.05^\circ \times 0.05^\circ$ (приблизительно $3 \times 5$ км).
    \item \textbf{Предварительная нарезка.} Применяется функция \texttt{ST\_Subdivide} для принудительного разбиения длинных геометрий на сегменты не более 500 метров\cite{postgis_vision_2018}. Это гарантирует, что ребро не будет пересекать более 4 смежных тайлов.
    \item \textbf{Локальная топологизация.} Построение узловой сети выполняется независимо для каждого тайла, что позволяет обрабатывать граф по частям, не выходя за пределы доступной оперативной памяти.
\end{enumerate}

В результате внедрения алгоритма максимальная длина ребра в графе сократилась с 8373 м до 871 м, что существенно повысило точность аппроксимации маршрутов. Сравнительный анализ эффективности подходов приведен в таблице~\ref{tab:oom-comparison}.

\begin{table}[h]
    \caption{Сравнение ресурсов при построении графа}
    \label{tab:oom-comparison}
    \begin{tabular}{|p{0.35\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
    \hline
    \textbf{Метрика} & \textbf{Стандартный подход} & \textbf{Секционирование (Наш метод)} \\ \hline
    Потребление памяти (RAM) & $> 12.4$ ГБ (сбой) & \textbf{370 МБ} \\ \hline
    Время выполнения & $> 2$ часов & \textbf{13 минут} \\ \hline
    Максимальная длина ребра & 8373 м & 871 м \\ \hline
    Результат & Аварийное завершение & Успешное построение \\ \hline
    \end{tabular}
\end{table}

\section{Алгоритм формирования альтернативных маршрутов}

\subsection{Критика эвристических алгоритмов в реляционных СУБД}
Классическим подходом к ускорению поиска пути является алгоритм A* (A-Star), использующий эвристическую функцию $h(v)$ для оценки расстояния до цели\cite{hart1968_scirp, astar_bstu_neuro, hart1968_auckland, hart1968_stfx}. Однако эксперименты показали его неэффективность в архитектуре Database-Centric\cite{hart1968_scienceopen}.

В реляционной модели координаты вершин хранятся в отдельной нормализованной таблице. Вычисление евклидовой эвристики $h(v) = \sqrt{(x_t - x_v)^2 + (y_t - y_v)^2}$ требует выполнения операции соединения таблиц базы данных (JOIN) на каждой итерации алгоритма. Это приводило к деградации производительности: время поиска маршрута длиной 30 км достигало 47 секунд, где 90\% времени занимали накладные расходы на извлечение координат\cite{hart1968_semantic}.

\subsection{Метод итеративных штрафов}
Вместо A* и классического алгоритма Йена (K-Shortest Paths), который часто возвращает топологически идентичные пути\cite{yen1971_mit, yen1971_ideas, eppstein1998_siam, yen1971_adrian, wiki_ksp_ru}, был применен метод итеративных штрафов (Iterative Penalty)\cite{roditty2012_replacement}, позволяющий также учитывать динамику среды\cite{iet_ppo_dynamic_2021}.

Алгоритм работает следующим образом:
\begin{enumerate}
    \item Находится кратчайший путь с текущими весами.
    \item Веса ребер $e$, входящих в найденный путь, увеличиваются согласно рекуррентной формуле:
    \begin{equation}
    w_{k}(e) = w_{k-1}(e) \cdot \mu
    \end{equation}
    где $\mu = 5.0$ — эмпирический коэффициент штрафа.
    \item Процедура повторяется $K$ раз.
\end{enumerate}

Такой подход вынуждает алгоритм искать маршруты, проходящие по принципиально другим улицам (например, набережная вместо проспекта), обеспечивая семантическое разнообразие альтернатив.

\subsection{Динамическое ограничение области поиска}
Для оптимизации производительности алгоритма Дейкстры используется метод динамического ограничивающего прямоугольника (Dynamic Bounding Box). Поиск выполняется не по всему графу, а только среди ребер, попадающих в область, определяемую формулой\cite{dijkstra1959_eudml}:
\begin{equation}
\delta(d) = \max(0.015^\circ, d \cdot 0.3)
\end{equation}
где $d$ — расстояние между точками старта и финиша по прямой. Данная эвристика позволяет отсечь до 90\% нерелевантных ребер графа, сокращая время поиска с десятков секунд до 0.9–2.1 секунды, сохраняя при этом гарантию нахождения оптимального пути (при достаточном коэффициенте запаса 0.3).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{components_map}
    \caption{Карта связности графа (Strongly Connected Components). Различными цветами выделены изолированные подграфы, не имеющие выхода на основную дорожную сеть.}
    \label{fig:components-map}
\end{figure}



\section{Выводы по второй главе}

Разработанная математическая модель и алгоритмическое обеспечение позволяют эффективно решать задачу маршрутизации в условиях ограничений реляционной СУБД. Применение алгоритма пространственного секционирования устранило проблему исчерпания оперативной памяти, снизив потребление с 12 ГБ до 370 МБ. Отказ от алгоритма A* в пользу оптимизированного алгоритма Дейкстры с динамическим ограничением области поиска позволил достичь приемлемой производительности без усложнения архитектуры хранения данных.
