\chapter{Математическое и алгоритмическое обеспечение системы}

\section{Математическая модель дорожной сети}

В основе навигационной системы лежит представление дорожной сети в виде взвешенного ориентированного графа $G = (V, E)$, где $V$ -- множество вершин, соответствующих перекресткам и тупикам, а $E$ -- множество ребер, представляющих участки дорог. Каждое ребро $e_{ij} \in E$, соединяющее вершины $v_i$ и $v_j$, характеризуется весовой функцией $w(e_{ij}, \tau)$, зависящей от времени $\tau$.

Целевая функция поиска оптимального маршрута $P^*$ формулируется как минимизация суммарной стоимости прохождения ребер маршрута\cite{dijkstra1959_yale}:
\begin{equation}
P^* = \arg \min_{P \in \mathcal{P}_{st}} \sum_{e \in P} w(e, \tau),
\end{equation}
где $\mathcal{P}_{st}$ -- множество всех допустимых путей из точки $s$ в точку $t$.

Весовая функция ребра $w(e, t)$ рассчитывается как прогнозируемое время прохождения участка с учетом динамических факторов:
\begin{equation}
    w(e, t) = \frac{L_e}{v_{eff}(e, t)},
\end{equation}
\where{
    $L_e$           & физическая длина участка дороги (в метрах); \\
    $v_{eff}(e, t)$ & эффективная скорость на участке в момент времени $t$.
}

Эффективная скорость моделируется на основе фундаментальной диаграммы транспортного потока (Гриншилдса). В упрощенном виде она зависит от коэффициента загруженности $K_{load}$:
\begin{equation}
    v_{eff} = v_{max} \cdot \eta_{surf} \cdot K_{load}(\rho),
\end{equation}
\where{
    $v_{max}$    & максимально допустимая скорость на участке (км/ч); \\
    $\eta_{surf}$ & коэффициент типа дорожного покрытия ($1.0$ -- асфальт, $0.6$ -- грунт); \\
    $K_{load}(\rho)$ & функция зависимости скорости от плотности потока.
}

Плотность потока $\rho$ нормируется относительно пропускной способности ребра, зависящей от числа полос $N_{lanes}$:
\begin{equation}
    \rho = \frac{N_{agents} \cdot L_{agent}}{L_e \cdot N_{lanes}},
\end{equation}
\where{
    $N_{agents}$ & текущее количество агентов на ребре; \\
    $L_{agent}$  & средняя длина транспортного средства (5 м); \\
    $N_{lanes}$  & количество полос движения.
}

При малой плотности ($\rho \to 0$) агенты движутся с максимальной разрешенной скоростью. При приближении к критической плотности (затор) скорость снижается до минимального порогового значения (например, 5-10 км/ч), что отражает нелинейный характер образования пробок\cite{greenshields1935_traffic}.
Данная модель позволяет системе динамически перераспределять маршруты, избегая участков с исчерпанной пропускной способностью.

\section{Плиточная декомпозиция графа для оптимизации ресурсов}

\subsection{Проблема исчерпания ресурсов при построении топологии}
Одной из ключевых технических проблем при обработке графа Московской агломерации (более 250 000 ребер) стало исчерпание оперативной памяти (Out Of Memory) при выполнении стандартной процедуры построения топологии \texttt{pgr\_nodeNetwork}. Данная функция пытается загрузить всю геометрию в память для поиска пересечений, что приводило к потреблению более 12 ГБ ОЗУ и аварийному завершению процесса (Exit Code 137). 

Анализ исходных данных выявил наличие сверхдлинных ребер (например, участки МКАД длиной до 8373 м), которые создавали «комбинаторный взрыв» при вычислении пересечений с локальной дорожной сетью.

\subsection{Алгоритм пространственного секционирования}
Для решения проблемы был разработан алгоритм пространственного секционирования графа (Grid Partitioning). Метод заключается в декомпозиции исходной области карты на независимые квадратные наборы (тайлы) фиксированного размера.

Процесс обработки включает следующие этапы:
\begin{enumerate}
    \item \textbf{Секционирование.} Вся область карты разбивается на тайлы размером $0.05^\circ \times 0.05^\circ$ (приблизительно $3 \times 5$ км).
    \item \textbf{Предварительная нарезка.} Применяется функция \texttt{ST\_Subdivide} для принудительного разбиения длинных геометрий на сегменты не более 500 метров\cite{postgis_vision_2018}. Это гарантирует, что ребро не будет пересекать более 4 смежных тайлов.
    \item \textbf{Локальная топологизация.} Построение узловой сети выполняется независимо для каждого тайла, что позволяет обрабатывать граф по частям, не выходя за пределы доступной оперативной памяти.
\end{enumerate}

В результате внедрения алгоритма максимальная длина ребра в графе сократилась с 8373 м до 871 м, что существенно повысило точность аппроксимации маршрутов. Сравнительный анализ эффективности подходов приведен в таблице~\ref{tab:oom-comparison}.

\begin{table}[h]
    \caption{Сравнение ресурсов при построении графа}
    \label{tab:oom-comparison}
    \begin{tabular}{|p{0.35\textwidth}|p{0.25\textwidth}|p{0.3\textwidth}|}
    \hline
    \textbf{Метрика} & \textbf{Стандартный подход} & \textbf{Секционирование (Наш метод)} \\ \hline
    Потребление памяти (RAM) & $> 12.4$ ГБ (сбой) & \textbf{370~МБ} \\ \hline
    Время выполнения & $> 2$ часов & \textbf{13 минут} \\ \hline
    Максимальная длина ребра & 8373 м & 871 м \\ \hline
    Результат & Аварийное завершение & Успешное построение \\ \hline
    \end{tabular}
\end{table}

\section{Алгоритм формирования альтернативных маршрутов}

\subsection{Критика эвристических алгоритмов в реляционных СУБД}
Классическим подходом к ускорению поиска пути является алгоритм A* (A-Star), использующий эвристическую функцию $h(v)$ для оценки расстояния до цели\cite{hart1968_scirp, astar_bstu_neuro, hart1968_auckland, hart1968_stfx}. Однако эксперименты показали его неэффективность в архитектуре Database-Centric\cite{hart1968_scienceopen}.

В реляционной модели координаты вершин хранятся в отдельной нормализованной таблице. Вычисление евклидовой эвристики $h(v) = \sqrt{(x_t - x_v)^2 + (y_t - y_v)^2}$ требует выполнения операции соединения таблиц базы данных (JOIN) на каждой итерации алгоритма. Это приводило к деградации производительности: время поиска маршрута длиной 30 км достигало 47~секунд, где 90~\% времени занимали накладные расходы на извлечение координат\cite{hart1968_semantic}.

\subsection{Метод итеративных штрафов}
Вместо A* и классического алгоритма Йена (K-Shortest Paths), который часто возвращает топологически идентичные пути\cite{yen1971_mit, yen1971_ideas, eppstein1998_siam, yen1971_adrian, wiki_ksp_ru}, был применен метод итеративных штрафов (Iterative Penalty)\cite{roditty2012_replacement}, позволяющий также учитывать динамику среды\cite{iet_ppo_dynamic_2021}.

Алгоритм работает следующим образом:
\begin{enumerate}
    \item Находится кратчайший путь с текущими весами.
    \item Веса ребер $e$, входящих в найденный путь, увеличиваются согласно рекуррентной формуле:
    \begin{equation}
    w_{k}(e) = w_{k-1}(e) \cdot \mu,
    \end{equation}
    \where{
        $\mu = 5.0$ & эмпирический коэффициент штрафа.
    }
    \item Процедура повторяется $K$ раз.
\end{enumerate}

Такой подход вынуждает алгоритм искать маршруты, проходящие по принципиально другим улицам (например, набережная вместо проспекта), обеспечивая семантическое разнообразие альтернатив.

\subsection{Динамическое ограничение области поиска}
Для оптимизации производительности алгоритма Дейкстры используется метод динамического ограничивающего прямоугольника (Dynamic Bounding Box). Поиск выполняется не по всему графу, а только среди ребер, попадающих в область, определяемую формулой\cite{dijkstra1959_eudml}:
\begin{equation}
\delta(d) = \max(0.015^\circ, d \cdot 0.3),
\end{equation}
\where{
    $d$ & евклидово расстояние между точками старта и финиша.
} 

Данная эвристика позволяет отсечь до 90~\% нерелевантных ребер графа, сокращая время поиска с десятков секунд до 0.9–2.1 секунды, сохраняя при этом гарантию нахождения оптимального пути (при достаточном коэффициенте запаса 0.3).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{components_map}
    \caption{Карта связности графа (Strongly Connected Components). Различными цветами выделены изолированные подграфы, не имеющие выхода на основную дорожную сеть.}
    \label{fig:components-map}
\end{figure}

\section{Выводы по второй главе}

Разработанная математическая модель и алгоритмическое обеспечение позволяют эффективно решать задачу маршрутизации в условиях ограничений реляционной СУБД. Применение алгоритма пространственного секционирования устранило проблему исчерпания оперативной памяти, снизив потребление с 12~ГБ до 370~МБ. Отказ от алгоритма A* в пользу оптимизированного алгоритма Дейкстры с динамическим ограничением области поиска позволил достичь приемлемой производительности без усложнения архитектуры хранения данных.
