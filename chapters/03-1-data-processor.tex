\section{Реализация подсистемы обработки пространственных данных}

Подсистема обработки данных (Data Processor) отвечает за взаимодействие с внешними источниками картографической информации OpenStreetMap\cite{pmc_osm_accuracy_2024}, построение топологически корректного дорожного графа и подготовку векторных тайлов для визуализации.

\subsection{Отказоустойчивая загрузка данных из OpenStreetMap}

Для обеспечения стабильного получения данных в условиях ограничений публичных API реализован механизм \textbf{ротации зеркал}. Система поддерживает пул адресов Overpass API, выбирая сервер по стратегии наименьшего количества ошибок подключения. При получении ответа \texttt{HTTP 429 Too Many Requests} применяется алгоритм экспоненциальной задержки \cite{eprints2023ratelimit}.

Для реализации теоретической модели данных, описанной в Главе \ref{chap:theory}, был сформирован следующий Overpass QL запрос (листинг \ref{lst:overpass-ql-impl}):

\begin{code}{overpass-ql-impl}{C++}{Запрос Overpass QL для фильтрации дорожного графа}
[out:json][timeout:timeout];
(
  // 1. Graph edge filtering by whitelist
  way["highway"~"^(motorway|trunk|primary|secondary|tertiary|residential|unclassified)$"](bbox);

  // 2. Turn Restrictions extraction
  relation["type"="restriction"](bbox);

  // 3. Point barriers extraction (Traffic Calming / Barriers)
  node["barrier"~"gate|boom|bollard|block|wall|lift_gate"](bbox);

  // 4. Access restrictions extraction
  way["access"="private"](bbox);
  way["access"="no"](bbox);
  way["motor_vehicle"="no"](bbox);
  way["service"="driveway"](bbox);
);

// Output phase:
out body;  // Metadata (ID and tags)
>;         // Recurse down
out skel qt; // Skeleton geometry
\end{code}

\subsection{Топологическая подготовка дорожного графа}

Процесс преобразования сырых геоданных в маршрутный граф является наиболее ресурсоемким этапом и выполняется в два основных шага.

\textbf{Этап 1: Предварительная геометрическая обработка и разделения слоев.}
Первичная обработка <<сырых>> данных, полученных из OSM, выполняется согласно графу состояний, изображенному на рисунке \ref{fig:build-flow}.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.75\textheight, keepaspectratio]{03-build-flow}
    \caption{Граф состояний алгоритма подготовки геометрии}
    \label{fig:build-flow}
\end{figure}

Процесс включает следующие стадии:
\begin{enumerate}
    \item \textbf{Геометрический препроцессинг}. Входящие линии разбиваются на сегменты фиксированной длины (ST\_Segmentize) и нарезаются на простые примитивы (ST\_Subdivide). Это необходимо для эффективной работы пространственных индексов.
    \item \textbf{Проверка топологического типа}. На основе атрибутов `layer`, `bridge` и `tunnel` определяется стратегия дальнейшей обработки:
    \begin{itemize}
        \item \textbf{Наземный слой} -- объекты нулевого уровня, для которых запускается ресурсоемкий алгоритм поиска пересечений (узлования) для формирования перекрестков. Строгая топологическая фиксация узлов на данном этапе необходима для последующего расчета весовых штрафов за маневрирование (например, левые повороты), что является критическим требованием для корректной работы алгоритмов мультиагентной навигации \cite{agv_astar_turning_2021}.
        \item \textbf{Изолированный слой} -- мосты и тоннели, которые копируются в целевой граф <<как есть>>, минуя стадию узлования, так как они физически изолированы от наземной дорожной сети.
    \end{itemize}
\end{enumerate}

\textbf{Этап 2: Секционирование графа.}
Обработка графа масштаба мегаполиса единым запросом приводит к исчерпанию оперативной памяти. Для решения этой проблемы применен метод итеративного секционирования \cite{sidorov2016clustering}, логика которого показана на рисунке \ref{fig:grid-partition}.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, keepaspectratio]{03-grid-partition}
    \caption{Метод секционирования для обработки графа}
    \label{fig:grid-partition}
\end{figure}

Алгоритм, реализованный в \texttt{db\_manager.py}, состоит из нескольких шагов.
\begin{enumerate}
    \item \textbf{Декомпозиция} -- глобальная область разбивается на тайлы размером $0.05^\circ \times 0.05^\circ$. Данный размер подобран экспериментально для обеспечения баланса между накладными расходами на транзакции и потреблением памяти.
    \item \textbf{Итеративная обработка} -- тайлы обрабатываются последовательно, что удерживает потребление памяти в пределах 370 МБ (табл. \ref{tab:grid-performance-res}).
    \item \textbf{Локальное узлование} -- для каждого тайла выполняется SQL-запрос с использованием буферной зоны (0.001 градуса) через \texttt{ST\_Expand} для корректной сшивки граничных ребер (листинг \ref{lst:grid-noding-sql}).
\end{enumerate}

\begin{code}{grid-noding-sql}{SQL}{Фрагмент запроса локального узлования (db\_manager.py)}
WITH selection AS (
    SELECT id, geom FROM edge_candidates 
    WHERE is_ground = TRUE AND geom && ST_Expand(tile_box, 0.001)
),
noded_geoms AS (
    -- Узлование только внутри текущего тайла
    SELECT (ST_Dump(ST_Node(ST_Collect(geom)))).geom 
    FROM selection
)
INSERT INTO edge_candidates_merged ...
\end{code}

Для ускорения финальной сборки топологии задействуются параллельные процессы PostgreSQL, количество которых адаптируется под число доступных ядер CPU (листинг \ref{lst:postgres-parallel}).

\begin{code}{postgres-parallel}{Python}{Настройка параллелизма PostgreSQL}
cur.execute("SET maintenance_work_mem = '2GB'")
cur.execute("SET max_parallel_workers_per_gather = 12") -- Адаптируется под количество ядер ЦП
\end{code}

Сравнительная оценка производительности предложенного алгоритма секционирования и стандартного подхода к построению графа представлена в таблице \ref{tab:grid-performance-res}. Результаты испытаний подтверждают, что итеративная обработка позволяет удерживать потребление оперативной памяти на константном уровне, предотвращая аварийное завершение процесса.

Сравнительная оценка производительности предложенного алгоритма и экспериментальные данные по потреблению памяти приведены в Главе \ref{chap:testing}.

\subsection{Событийно-ориентированный протокол обновлений}

Система реализует протокол \textbf{ленивой загрузки} для оптимизации сетевого трафика. Схема взаимодействия клиента и сервера представлена на рисунке \ref{fig:tile-loading}.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.7\textheight, keepaspectratio]{03-tile-loading}
    \caption{Схема ленивой загрузки тайлов и обработки статусов (202/204)}
    \label{fig:tile-loading}
\end{figure}

Взаимодействие компонентов происходит следующим образом:
\begin{enumerate}
    \item Клиент отправляет запрос на получение тайла.
    \item Сервер проверяет наличие готовых данных в кэше. При отсутствии актуального тайла создается фоновая задача, а клиенту возвращается статус \texttt{HTTP 202 Accepted}.
    \item Фоновый воркер выполняет загрузку данных из OSM, построение топологии и генерацию MVT.
    \item По завершении обработки сервер отправляет уведомление \texttt{tiles\_invalidated} через WebSocket, инициируя повторный запрос клиента.
\end{enumerate}

\subsection{Генерация векторных тайлов}

Векторные тайлы формируются динамически с использованием функции \texttt{ST\_AsMVT} \cite{kuvshinov2025mvt, maplibre2025mvt}. Для корректного визуального отображения развязок применяется Z-сортировка на уровне SQL-запроса (листинг \ref{lst:z-order-sql}).

\begin{code}{z-order-sql}{SQL}{Сортировка объектов по приоритету отрисовки (queries.py)}
ORDER BY
    CASE highway
        WHEN 'motorway' THEN 10     -- Магистрали (сверху)
        WHEN 'trunk' THEN 9
        WHEN 'primary' THEN 8
        -- ...
        WHEN 'residential' THEN 4
        ELSE 0                      -- Прочие (снизу)
    END ASC
\end{code}

Использование конструкции \texttt{CASE/WHEN} гарантирует, что скоростные магистрали и мосты будут отрисованы поверх локальной дорожной сети, что соответствует их физическому расположению.
