\section{Разработка клиентского модуля и механизмов интеграции}

Клиентская часть комплекса (Qt Client) реализована как гибридное настольное приложение, объединяющее нативный функционал и современные веб-технологии визуализации.

\subsection{Пользовательский интерфейс и управление}

Главное окно приложения (рисунок~\ref{fig:client-main}) разделено на две функциональные области: интерактивную карту и боковую панель управления (Sidebar). Боковая панель содержит набор виджетов для управления процессом маршрутизации:

\begin{itemize}
    \item \textbf{Панель маршрутных точек (Points Panel):} Позволяет пользователю задавать начальную (Start), конечную (End) и промежуточные (Via) точки маршрута. Реализован функционал добавления, удаления и изменения порядка следования точек. Координаты могут быть введены вручную или выбраны кликом по карте.
    \item \textbf{Панель результатов (Routes Panel):} Отображает список найденных альтернативных маршрутов (K-Shortest Paths). Для каждого маршрута выводятся ключевые метрики: общая протяженность (км), расчетное время в пути (мин) и количество ребер графа. Выбор элемента в списке подсвечивает соответствующую траекторию на карте.
    \item \textbf{Управление симуляцией (Simulation Panel):} Блок элементов интерфейса (<<Sim Speed>>, <<FPS>>, управление агентом), зарезервированный для подсистемы мультиагентного моделирования. В текущей версии системы эти элементы демонстрируют готовность архитектуры к внедрению динамических агентов (автомобилей), движущихся по построенным маршрутам, но их функционал пока ограничен базовой отладкой.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{gui-routes}
    \caption{Главное окно приложения. Слева -- панель управления с параметрами маршрута (K=5) и списком найденных путей. На карте отображены 5 маршрутов (синим цветом выбранный в панели результатов маршрут, серым -- остальные), проходящих через заданные точки.}
    \label{fig:client-main}
\end{figure}

\subsection{Гибридная архитектура и выбор движка рендеринга}

Классические виджеты Qt (QGraphicsView) не предназначены для отрисовки миллионов векторных объектов с частотой 60 кадров в секунду. Попытка реализации карты на чистом C++/Python привела бы к необходимости написания собственной системы тайлинга и управления GPU-шейдерами. С другой стороны, чистое веб-приложение в браузере ограничено <<песочницей>> (Sandbox) и не имеет прямого доступа к файловой системе и оборудованию, что критически важно для целей исследования (сбор локальных метрик, работа без интернета).

В качестве архитектурного решения выбрана концепция <<толстого клиента>> с использованием компонента \texttt{QWebEngineView} (на базе Chromium). Рендеринг карты делегирован библиотеке \textbf{MapLibre GL JS}, использующей WebGL для аппаратного ускорения графики \cite{maplibre_main, jawg_maplibre_vs_leaflet, maplibre_vectortile_source, maplibre_hybrid_terrain}.
Основная логика приложения (меню, управление симуляцией, сетевой обмен) реализована на Python (PyQt5), а визуализация -- на JavaScript.

В архитектуре системы реализован двухступенчатый конвейер преобразования координат для генерации тайлов (MVT).

\textbf{Этап 1: Проецирование (EPSG:4326 $\to$ EPSG:3857).}
Исходные данные OpenStreetMap поступают в географической системе координат WGS 84 (широта/долгота). Поскольку стандарт векторных тайлов Mapbox Vector Tile требует предварительного проецирования в плоскую метрическую систему Web Mercator, данное преобразование выполняется на этапе импорта данных (см. \texttt{queries.py}). В базе данных хранятся обе геометрии: оригинальная (\texttt{geom}) и спроецированная (\texttt{geom\_3857}). Это позволяет избежать ресурсоемких вычислений \texttt{ST\_Transform} при каждом запросе тайла.

Формула прямого преобразования Меркатора:
\begin{equation}
\begin{cases}
x = R \cdot \lambda \\
y = R \cdot \ln\left(\tan\left(\frac{\pi}{4} + \frac{\phi}{2}\right)\right)
\end{cases},
\end{equation}
\where{
    $R$ & радиус Земли (6378137 м); \\
    $\lambda$ & долгота в радианах; \\
    $\phi$ & широта в радианах.
}

\textbf{Этап 2: Аффинное преобразование в координаты тайла.}
Для передачи на клиент спроецированные координаты (метры) переводятся в локальную целочисленную систему координат тайла (Screen Coordinates) с помощью матрицы масштабирования и сдвига:
\begin{equation}
\begin{pmatrix} X_{tile} \\ Y_{tile} \end{pmatrix} = \begin{pmatrix} S/W_z & 0 \\ 0 & -S/W_z \end{pmatrix} \begin{pmatrix} x_{merc} - x_{origin} \\ y_{merc} - y_{origin} \end{pmatrix},
\end{equation}
\where{
    $X_{tile}, Y_{tile}$ & координаты точки внутри тайловой системы координат (экранные координаты, обычно целые числа); \\
    $S$ & разрешение тайла (Extent = 4096 единиц); \\
    $W_z$ & ширина области, охватываемой тайлом на уровне масштаба $z$ (в метрах); \\
    $x_{merc}, y_{merc}$ & координаты исходной точки в глобальной проекции Web Mercator (EPSG:3857); \\
    $x_{origin}, y_{origin}$ & координаты левого верхнего угла тайла в проекции Web Mercator.
}

Данный подход обеспечивает баланс между точностью и скоростью: хранение в EPSG:3857 ускоряет выборку (индекс GiST работает по плоским координатам), а локальные координаты тайла снимают проблему дрожания (Jittering) на клиенте из-за ограничений Float32 в GPU.

Гибридный подход объединил производительность PyQt5 и гибкость веб-разработки. Использование MVT перенесло вычислительную нагрузку по проекции (Projection) и упрощению геометрии (Simplification) на сервер БД\cite{crunchy_dynamic_tiles}, освободив ресурсы клиента для плавной анимации интерфейса.

\subsection{Механизм мостов QWebChannel}

Существенным препятствием при интеграции является изоляция процессов Python и JavaScript, которая препятствует прямому вызову функций. Использование HTTP-сервера только для межпроцессного взаимодействия (IPC) внутри одного приложения добавляет неоправданную задержку (Latency ок. 10-15 мс) и усложняет архитектуру.

Для организации двунаправленного канала связи применен протокол \texttt{QWebChannel} поверх WebSocket транспортного уровня. Разработаны специализированные объекты-мосты (Bridges), которые экспортируются из контекста Python в глобальную область видимости \texttt{window} браузера:

\begin{itemize}
    \item \textbf{ZoomBridge.} Отслеживает уровень масштаба карты. При изменении зума (событие \texttt{zoomend} в JS) он уведомляет бэкенд о необходимости пересчета уровня детализации (LOD).
    \item \textbf{ConfigBridge.} Передает JSON-схему стилей (Map Style Spec)\cite{maplibre_style_spec} при инициализации карты, позволяя управлять цветами дорог и толщиной линий из единого конфигурационного файла приложения.
    \item \textbf{LoggerBridge.} Перехватывает вызовы \texttt{console.log / error} в JavaScript и транслирует их в стандартный поток вывода Python. Это позволяет видеть ошибки JS-кода в общем логе systemd.
\end{itemize}

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.85\textheight, keepaspectratio]{03-qwebchannel-seq}
    \caption{Схема взаимодействия через QWebChannel}
    \label{fig:qwebchannel-seq}
\end{figure}

На диаграмме \ref{fig:qwebchannel-seq} представлены четыре основных сценария взаимодействия сред выполнения.
\begin{enumerate}
    \item \textbf{Инициализация}. При старте приложения Python-бэкенд регистрирует объекты-мосты (\texttt{config}, \texttt{logger}, \texttt{zoom}). После загрузки страницы во фронтенд инъектируется объект \texttt{window.qt}, обеспечивающий доступ к методам Python из JavaScript.
    \item \textbf{Сценарий 1: Перехват логов}. Для централизованной диагностики переопределен метод \texttt{console.error}. Сообщения об ошибках тайлов или скриптов транслируются через \texttt{LoggerBridge} в стандартный поток ошибок Python (stderr), что позволяет агрегировать логи фронтенда и бэкенда в единой системе логгирования \texttt{loguru}.
    \item \textbf{Сценарий 2: Синхронизация LOD}. При изменении масштаба карты (событие \texttt{zoomend}) JavaScript вызывает метод \texttt{zoom.onZoomChanged}. Python-бэкенд получает новое значение $Z$, пересчитывает стратегию детализации и обновляет параметры SQL-фильтрации через Data Processor.
    \item \textbf{Сценарий 3: Управление камерой}. Обратный канал связи реализуется через метод \texttt{runJavaScript}. Например, при перемещении мышью по карте Python генерирует команду \texttt{map.flyTo({...})}, инициируя плавную WebGL-анимацию полета камеры в выбранном направлении.
\end{enumerate}

\subsection{Реактивная синхронизация детализации (LOD)}

При отображении карты на мелком масштабе (например, весь город), попытка загрузить все дороги (включая дворовые проезды) приводит к перегрузке видеопамяти и визуальному шуму. Необходима динамическая фильтрация контента в зависимости от зума (Zoom Level).

Для оптимизации рендеринга реализован следующий реактивный цикл синхронизации:
\begin{enumerate}
    \item пользователь меняет масштаб карты колесом мыши;
    \item модуль JS вызывает метод ZoomBridge $\rightarrow$ модуля Python;
    \item модуль Python отправляет новый уровень LOD (Level of Detail) в сервис Data Processor через WebSocket;
    \item сервис Data Processor обновляет параметры SQL-фильтрации (например, \texttt{WHERE highway IN ('motorway', 'primary')});
    \item карта перезагружает тайлы.
\end{enumerate}

Полное время цикла синхронизации (Round Trip Time) описывается формулой:
\begin{equation}
T_{sync} \approx T_{ws\_latency} + T_{config\_parse} + T_{invalidate\_cache} \approx 65 \text{ мс},
\end{equation}
\where{
    $T_{ws\_latency}$ & сетевая задержка WebSocket; \\
    $T_{config\_parse}$ & время парсинга конфигурации; \\
    $T_{invalidate\_cache}$ & время инвалидации кэша тайлов.
}

Такая задержка является незаметной для человеческого глаза (порог восприятия 100 мс).

Динамический LOD снизил нагрузку на рендеринг в 10 раз при просмотре обзорных карт, скрывая до 90~\% мелких объектов. Это позволило добиться стабильных 60 FPS даже на интегрированных видеокартах.

Эффективность работы алгоритма динамической детализации наглядно представлена на рисунке \ref{fig:client-lod}. На низких уровнях масштабирования (z9) рендеринг ограничивается только магистральной сетью, что обеспечивает чистоту восприятия. По мере приближения (z11--z15) система последовательно подгружает локальные дороги, дворовые проезды и служебные пути.

\begin{figure}[H]
    \centering
    % --- Первая строка ---
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{gui-lod-1}
        \caption{Низкий масштаб (z9): только магистрали}
        \label{fig:lod-z9}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{gui-lod-2}
        \caption{Средний масштаб (z11): региональные дороги}
        \label{fig:lod-z11}
    \end{subfigure}
    
    \vspace{1em}
    % --- Вторая строка ---
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{gui-lod-3}
        \caption{Высокий масштаб (z13): уличная сеть}
        \label{fig:lod-z13}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{gui-lod-4}
        \caption{Макс. детализация (z15): дворы}
        \label{fig:lod-z15}
    \end{subfigure}
    \caption{Демонстрация работы системы LOD: прогрессивная детализация дорожной сети}
    \label{fig:client-lod}
\end{figure}

\subsection{Визуальное кодирование и атрибутивный состав}

Для улучшения читаемости карты оператором реализована система цветового кодирования классов дорог (см. таблицу \ref{tab:road-attributes}). Каждому функциональному классу (тэг `highway`) сопоставлен уникальный цвет и толщина линии, что позволяет мгновенно оценивать связность дорожной сети.
Кроме того, в системе зафиксированы расчетные скоростные лимиты для каждого класса, используемые при построении изохрон и маршрутов.

\begin{table}[H]
    \centering
    \caption{Цветовое кодирование типов дорог и скоростной режим}
    \label{tab:road-attributes}
    \small
    \begin{tabular}{|l|l|c|}
        \hline
        \textbf{Тип дороги (OSM tag)} & \textbf{Цвет (HEX)} & \textbf{Speed (км/ч)} \\ \hline
        Motorway & \textcolor[HTML]{1E40AF}{\rule{1cm}{3mm}} \#1E40AF (Dark Blue) & 110 \\ \hline
        Trunk & \textcolor[HTML]{6200FF}{\rule{1cm}{3mm}} \#6200FF (Purple) & 110 \\ \hline
        Primary & \textcolor[HTML]{9C00AA}{\rule{1cm}{3mm}} \#9C00AA (Magenta) & 60 \\ \hline
        Secondary & \textcolor[HTML]{FF5EFF}{\rule{1cm}{3mm}} \#FF5EFF (Pink) & 60 \\ \hline
        Tertiary & \textcolor[HTML]{FF2E2E}{\rule{1cm}{3mm}} \#FF2E2E (Red) & 60 \\ \hline
        Unclassified & \textcolor[HTML]{5C5C5C}{\rule{1cm}{3mm}} \#5C5C5C (Gray) & 60 \\ \hline
        Residential / Living & \textcolor[HTML]{FF8635}{\rule{1cm}{3mm}} \#FF8635 (Orange) & 20 \\ \hline
        Service & \textcolor[HTML]{008D0C}{\rule{1cm}{3mm}} \#008D0C (Green) & 20 \\ \hline
    \end{tabular}
\end{table}
