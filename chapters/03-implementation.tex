\chapter{Реализация подсистемы маршрутизации}
\label{ch:implementation}

В данном разделе рассматриваются ключевые алгоритмические и архитектурные решения, позволившие реализовать масштабируемую систему маршрутизации на базе PostgreSQL. Основное внимание уделено двум аспектам: эффективному построению дорожного графа в условиях ограниченных ресурсов и реализации гибридного алгоритма поиска пути.

\section{Архитектура хранения пространственных данных}

Для обеспечения целостности данных и оптимизации производительности была разработана двухуровневая схема хранения. Данные OpenStreetMap (OSM) хранятся в <<сыром>> виде для обеспечения возможности обновлений, в то время как маршрутный граф представляет собой оптимизированную топологическую структуру.

Схема взаимодействия таблиц представлена на диаграмме (рисунок~\ref{fig:graph-schema}).

\begin{figure}[H]
    \centering
    \includemermaid{03-graph-schema}
    \caption{ER-диаграмма схем OSM (источник) и GRAPHS (топология)}
    \label{fig:graph-schema}
\end{figure}

Ключевой особенностью является сохранение связи (Data Lineage) между ребром графа (`graphs.edges`) и исходной линией (`osm.ways`) через внешний ключ. Это позволяет динамически подтягивать любые атрибуты (например, время работы или ограничения по весу) без необходимости перестройки топологии.

\section{Процесс построения дорожного графа}

Построение графа из сырых геоданных — вычислительно сложная задача, требующая поиска всех пересечений дорог (Noding). Классический подход загрузки всех данных в оперативную память оказался неприменим для дорожной сети Москвы (более 250 000 рёбер), вызывая переполнение памяти (OOM) на серверах с 16 ГБ RAM.

\subsection{Алгоритм Grid Partitioning}

Для решения проблемы OOM был разработан алгоритм плиточной нарезки (Grid Partitioning). Идея заключается в декомпозиции глобальной задачи на множество локальных подзадач, решаемых независимо.

Общая схема процесса построения представлена на рисунке~\ref{fig:build-flow}.

\begin{figure}[H]
    \centering
    \includemermaid[width=0.55\linewidth]{03-build-flow}
    \caption{Алгоритм построения графа}
    \label{fig:build-flow}
\end{figure}

Процесс состоит из следующих этапов.

\textbf{Этап 1. Препроцессинг и фильтрация слоёв.}
Перед нарезкой выполняется разделение геометрий на группы. Дороги, проходящие на разных уровнях (мосты, тоннели), не должны образовывать перекрестков с дорогами на земле.
\begin{enumerate}
    \item \textbf{Ground Layer:} Обычные дороги (`layer=0`). Подлежат полной топологической обработке.
    \item \textbf{Isolated Layer:} Мосты и тоннели (`bridge=yes`, `tunnel=yes`). Исключаются из поиска пересечений, чтобы избежать создания ложных узлов в местах визуального наложения линий в 2D-проекции.
\end{enumerate}
Кроме того, применяется функция `ST\_Subdivide` для разбиения длинных геометрий (например, МКАД длиной 109 км) на сегменты не более 500 метров. Это улучшает эффективность пространственных индексов.

\textbf{Этап 2. Параллельная обработка тайлов.}
Территория разбивается на тайлы размером $0.05^\circ \times 0.05^\circ$. Обработка каждого тайла происходит независимо (рисунок~\ref{fig:grid-partition}), что позволяет линейно масштабировать процесс по количеству ядер CPU.

\begin{figure}[H]
    \centering
    \includemermaid{03-grid-partition}
    \caption{Параллельная обработка тайлов}
    \label{fig:grid-partition}
\end{figure}

Внутри каждого тайла выполняется функция `pgr\_nodeNetwork` в оперативной памяти процесса Python. Это снизило потребление RAM с 12 ГБ до 370 МБ и сократило время полной сборки графа с 4 часов до 13 минут.

\textbf{Этап 3. Наследование атрибутов.}
В процессе нарезки (`ST\_Node`) исходные линии дробятся на мелкие сегменты, теряя свои атрибуты. Для восстановления данных реализован алгоритм пространственного сопоставления:
\begin{equation}
L_{overlap} = \text{Length}(\text{Intersection}(E_{new}, E_{old}))
\label{eq:overlap}
\end{equation}
Если $L_{overlap} > 0.8 \cdot \text{Length}(E_{new})$, то сегмент $E_{new}$ наследует название улицы, скоростной режим и тип дороги от $E_{old}$. Это фильтрует случайные пересечения.

\subsection{Анализ связности графа}
После построения выполняется проверка на наличие изолированных <<островов>> — участков дорожной сети, не имеющих выхода в основную компоненту (закрытые поселки, ошибки картографии).
Анализ с помощью `pgr\_connectedComponents` показал, что основная компонента связности охватывает 98.4\% всех ребер, что соответствует критериям качества для навигационных систем. Оставшиеся 1.6\% представляют собой действительно изолированные зоны или ошибки данных OSM, которые исключаются из маршрутизации.

\section{Реализация алгоритмов поиска пути}

Ядро маршрутизации реализовано на уровне SQL-функций PostgreSQL, что минимизирует накладные расходы на передачу данных между диском и приложением.

\subsection{Жизненный цикл запроса}
Обработка пользовательского запроса проходит через конвейер фильтрации и постобработки (рисунок~\ref{fig:runtime-flow}).

\begin{figure}[H]
    \centering
    \includemermaid[width=0.55\linewidth]{03-runtime-flow}
    \caption{Конвейер обработки запроса маршрутизации}
    \label{fig:runtime-flow}
\end{figure}

\textbf{Привязка к графу (Smart Snapping).}
Вместо поиска ближайшего ребра, который может привести к ошибкам на многоуровневых развязках (привязка к туннелю под землей), используется поиск $K$ ближайших узлов (Vertex Snapping) с помощью KNN-индекса (`<->` operator в PostGIS). Это гарантирует, что маршрут начнется с валидной точки (перекрестка или примыкания).

\textbf{Динамическое ограничение области (Dynamic BBOX).}
Для оптимизации производительности поиск выполняется не по всему графу (250 тыс. ребер), а только внутри ограничивающего прямоугольника, охватывающего старт и финиш, с буфером 30\%:
\begin{equation}
Buffer = \max(1.5 \text{ km}, 0.3 \cdot \text{Distance}(Start, End))
\label{eq:bbox-buffer}
\end{equation}
Это сократил время поиска для локальных маршрутов с 3.2 с до 0.9 с.

\subsection{Алгоритм Iterative Penalty Dijkstra}
Для построения альтернативных маршрутов ($K$-Shortest Paths) используется метод итеративных штрафов, так как стандартный алгоритм Йена (Yen's Algorithm) склонен генерировать пути с незначительными отличиями (микро-объезды).

Алгоритм работает следующим образом:
\begin{enumerate}
    \item Найти кратчайший путь $R_1$ с помощью алгоритма Дейкстры.
    \item Увеличить стоимость всех ребер, входящих в $R_1$, в 5 раз: $Cost(e) \leftarrow Cost(e) \cdot 5.0$.
    \item Запустить поиск снова для нахождения $R_2$.
    \item Повторить $K$ раз.
\end{enumerate}
Коэффициент штрафа 5.0 подобран эмпирически: он заставляет алгоритм искать принципиально иные пути (например, через другую магистраль), но не приводит к абсурдным объездам.

\subsection{Коррекция геометрии (Zig-Zag Fix)}
В исходных данных OSM линии имеют направление оцифровки. Если маршрут проходит <<против шерсти>> двусторонней дороги, сырая геометрия будет инвертирована. Для устранения артефактов визуализации (<<зубья пилы>>) применяется динамический разворот геометрии:
\begin{code}{zigzag-fix}{SQL}{Коррекция геометрии (Zig-Zag Fix)}
CASE 
    WHEN op.node = edge.source THEN edge.geometry 
    ELSE ST_Reverse(edge.geometry) 
END
\end{code}
Это обеспечивает непрерывность линии маршрута на клиенте.

\section{Оптимизация потребления ресурсов}

Одной из критических проблем, выявленных на этапе прототипирования, стало исчерпание оперативной памяти (OOM) при попытке построить граф дорожной сети Москвы целиком. Классический подход требовал загрузки всех 250 000 ребер в память для построения топологии.

Применение разработанного алгоритма Grid Partitioning позволило радикально снизить требования к оборудованию. Сравнительные характеристики приведены в таблице~\ref{tab:oom-comparison}.

\begin{table}[H]
    \centering
    \caption{Сравнение потребления ресурсов (Legacy vs Grid Partitioning)}
    \label{tab:oom-comparison}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Параметр} & \textbf{Монолитный подход} & \textbf{Grid Partitioning} & \textbf{Эффект} \\ \hline
        Пиковое RAM & 12.4 ГБ & 370 МБ & $\downarrow$ 33.5x \\ \hline
        Время сборки & 4 ч 15 мин & 13 мин & $\downarrow$ 19.6x \\ \hline
        Стабильность & OOM Crash & 100\% Success & Решено \\ \hline
    \end{tabular}
\end{table}

\section{Реализация подсистемы Gateway}

Шлюз (Gateway) играет роль единой точки входа и обеспечивает прозрачное проксирование WebSocket-соединений. Реализация основана на асинхронном фреймворке \texttt{FastAPI} и библиотеке \texttt{websockets}.

\subsection{Проксирование WebSocket}
Для обеспечения дуплексной связи между клиентом и сервисом маршрутизации используется механизм <<трубы>> (pipe), реализованный через \texttt{asyncio.gather}. Шлюз одновременно запускает две задачи: чтение от клиента с отправкой в сервис и чтение от сервиса с отправкой клиенту (рисунок~\ref{fig:gateway-seq}).

\begin{figure}[H]
    \centering
    \includemermaid{03-gateway-seq}
    \caption{Диаграмма последовательности проксирования WebSocket}
    \label{fig:gateway-seq}
\end{figure}

\subsection{Декларативная маршрутизация}
Конфигурация маршрутов вынесена в YAML-файл, что позволяет добавлять новые микросервисы без пересборки шлюза:

\begin{code}{route-registry}{yaml}{Фрагмент route\_registry.yaml}
routes:
  - path: "/ws/route"
    service_url: "ws://router:8002/ws"
    type: "websocket"
  - path: "/tiles/{z}/{x}/{y}.pbf"
    service_url: "http://data_processor:8001/tiles"
    type: "http"
\end{code}

\section{Реализация клиентского приложения}

Интерфейс приложения разработан с использованием фреймворка Qt (модуль Qt Widgets) для реализации панелей управления и компонента \texttt{QWebEngineView} для отображения интерактивной карты. Архитектура UI построена по принципу разделения ответственности: логика взаимодействия с картой вынесена в JavaScript-модули, а управление состоянием приложения и сетевое взаимодействие — в Python-код.

\subsection{Пользовательский интерфейс и управление}

Главное окно приложения (рисунок~\ref{fig:client-main}) разделено на две функциональные области: интерактивную карту и боковую панель управления (Sidebar). Боковая панель содержит набор виджетов для управления процессом маршрутизации:

\begin{itemize}
    \item \textbf{Панель маршрутных точек (Points Panel):} Позволяет пользователю задавать начальную (Start), конечную (End) и промежуточные (Via) точки маршрута. Реализован функционал добавления, удаления и изменения порядка следования точек. Координаты могут быть введены вручную или выбраны кликом по карте.
    \item \textbf{Панель результатов (Routes Panel):} Отображает список найденных альтернативных маршрутов (K-Shortest Paths). Для каждого маршрута выводятся ключевые метрики: общая протяженность (км), расчетное время в пути (мин) и количество ребер графа. Выбор элемента в списке подсвечивает соответствующую траекторию на карте.
    \item \textbf{Управление симуляцией (Simulation Panel):} Блок элементов интерфейса («Sim Speed», «FPS», управление агентом), зарезервированный для подсистемы мультиагентного моделирования. В текущей версии системы эти элементы демонстрируют готовность архитектуры к внедрению динамических агентов (автомобилей), движущихся по построенным маршрутам, но их функционал пока ограничен базовой отладкой.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{gui-routes}
    \caption{Главное окно приложения. Слева — панель управления с параметрами маршрута (K=5) и списком найденных путей. На карте фиолетовым цветом отображены 5 альтернативных маршрутов, проходящих через заданные точки.}
    \label{fig:client-main}
\end{figure}

\subsection{Система уровней детализации (LOD)}

Для обеспечения высокой производительности при отображении графа, содержащего более 250 000 ребер, реализована серверная фильтрация данных (Level of Detail). 

В отличие от классического подхода, где фильтрация происходит на клиенте (скрытие слоев через CSS), система реализует \textit{динамическую генерацию тайлов}. При запросе тайла сервер Data Processor проверяет текущий уровень масштабирования (Zoom Level) и модифицирует SQL-запрос к базе данных, исключая геометрию второстепенных дорог, невидимых на данном масштабе. Это позволяет радикально снизить объем передаваемых данных (размер MVT-тайла) и нагрузку на клиентский рендеринг.

Эффект от применения LOD продемонстрирован на рисунке~\ref{fig:client-lod}:
\begin{itemize}
    \item \textbf{(а) z9:} Отображаются только магистрали федерального значения (Motorway, Trunk).
    \item \textbf{(б) z11:} Добавляются дороги регионального значения (Primary, Secondary).
    \item \textbf{(в) z13:} Становится видна основная уличная сеть.
    \item \textbf{(г) z15:} Загружается полная геометрия, включая дворовые проезды и служебные дороги.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\linewidth]{gui-lod-1} & \includegraphics[width=0.45\linewidth]{gui-lod-2} \\
        \small (а) Низкий масштаб (z9) & \small (б) Средний масштаб (z11) \\
        \includegraphics[width=0.45\linewidth]{gui-lod-3} & \includegraphics[width=0.45\linewidth]{gui-lod-4} \\
        \small (в) Высокий масштаб (z13) & \small (г) Максимальная детализация (z15)
    \end{tabular}
    \caption{Демонстрация работы системы LOD: прогрессивная детализация дорожной сети}
    \label{fig:client-lod}
\end{figure}

\subsection{Рендеринг векторных тайлов (MVT)}
Для корректного отображения сложной городской застройки (мосты над дорогами, тоннели) на стороне клиента реализована сортировка объектов по Z-индексу (Z-Order). Векторные тайлы, генерируемые сервером, содержат атрибут \texttt{layer}, который используется стилями MapLibre GL JS для определения порядка отрисовки. Без этого механизма дороги могли бы визуально перекрывать мосты, проходящие под ними.

