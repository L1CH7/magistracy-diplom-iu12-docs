\section{Анализ задачи маршрутизации в динамической среде}

Задача поиска оптимального маршрута в транспортной сети сводится к нахождению кратчайшего пути во взвешенном ориентированном графе $G = (V, E)$, где каждая вершина $v \in V$ соответствует перекрестку, а ребро $e \in E$ — дорожному участку. В классической постановке задачи веса $w(e)$ считаются постоянными, что позволяет использовать эффективные алгоритмы предварительной обработки, такие как Contraction Hierarchies (CH)\cite{geisberger2008_researchgate}. Данный метод сокращает время запроса до миллисекунд за счет построения иерархии сокращений.

Однако в условиях городской среды веса ребер $w(e, t)$ являются функцией времени, изменяясь под воздействием пробок, аварий или перекрытий дорог.

\subsection{Критика In-Memory решений}
Анализ показал фундаментальные ограничения популярных движков:
\begin{enumerate}
    \item \textbf{OSRM}. Жесткая привязка к статическим данным. Изменение веса одного ребра требует перезапуска процесса предобработки, который для крупных графов занимает до часа. Бенчмарки показывают экстремальную скорость поиска (<10 мс), но полную невозможность работы с динамикой в реальном времени. Как отмечается в исследовании RouteXL, OSRM теряет свою эффективность при необходимости учета динамических ограничений, таких как временные перекрытия дорог\cite{routexl2025comparison}.
    \item \textbf{GraphHopper}. Потребляет значительный объем оперативной памяти (Java Heap) и имеет ограниченную поддержку динамических весов через профили ("Flexible Mode"), что все же требует перестройки индексов.
\end{enumerate}

В противовес им, подход \textbf{pgRouting} на базе PostgreSQL позволяет учитывать изменения весов мгновенно. Любой маршрут, построенный SQL-запросом, всегда отражает актуальное состояние базы данных без необходимости предварительных вычислений\cite{crunchydata2026routing}.

\section{Обоснование выбора архитектуры Database-Centric}

На основе анализа было принято решение использовать архитектуру \textit{Database-Centric}. Граф дорог хранится и обрабатывается непосредственно в реляционной СУБД PostgreSQL. Данный подход обладает рядом преимуществ для геоинформационных систем\cite{basargin2021pgrouting}:
\begin{enumerate}
    \item \textbf{Транзакционная целостность (ACID).} Маршруты строятся на основе согласованного снимка данных (MVCC), даже если параллельно идут процессы обновления графа.
    \item \textbf{Единая точка истины.} Локационные и бизнес-данные (пробки, инциденты) находятся в одном хранилище, устраняя необходимость синхронизации с внешними поисковыми индексами\cite{percona2025postgis}.
\end{enumerate}

Для выбора платформы был проведен сравнительный анализ существующих решений \cite{routexl2025comparison, gisops2018routing}. На современном рынке выделяются два основных класса систем:

\begin{enumerate}
    \item \textbf{In-Memory движки с предварительной обработкой} (OSRM, GraphHopper, Valhalla). Ориентированы на максимальную производительность поиска (Query Time) за счет сложного этапа "запекания" данных (Pre-processing). Граф компилируется в оптимизированные структуры данных (иерархии сокращений или тайлы).
    \item \textbf{Database-Centric решения} (pgRouting). Ориентированы на гибкость и работу с динамическими данными непосредственно в СУБД без предварительного построения индексов.
\end{enumerate}

В таблице \ref{tab:routing-engines-general} представлено сравнение архитектурных особенностей данных решений.

\begin{table}[H]
    \centering
    \caption{Сравнительный анализ архитектурных подходов к маршрутизации}
    \label{tab:routing-engines-general}
    \begin{tabular}{|p{0.15\linewidth}|p{0.25\linewidth}|p{0.25\linewidth}|p{0.25\linewidth}|}
    \hline
    \textbf{Решение} & \textbf{Алгоритм оптимизации} & \textbf{Механизм работы} & \textbf{Ограничения для динамических графов} \\ \hline
    \textbf{OSRM} & Contraction Hierarchies (CH) / MLD & Строит иерархию "сокращений" (shortcuts) во время препроцессинга. & Любое изменение весов требует полной перестройки графа (до 1 часа для Москвы). \\ \hline
    \textbf{GraphHopper} & CH / Landmarks (ALT) & Использует гибридный подход. Режим "Flexible" позволяет менять параметры, но без изменения топологии. & Высокое потребление Java Heap. Пересчет весов в реальном времени неэффективен. \\ \hline
    \textbf{Valhalla} & Tiled Hierarchical & Граф разбит на тайлы. \textbf{Dynamic Costing} вычисляет стоимость на основе атрибутов тайла \cite{saki2022mapmatching}. & Обновление весов требует пересборки тайлов и перезапуска сервиса. Максимальная частота обновления -- раз в неделю (historical traffic). \\ \hline
    \textbf{pgRouting} & \textbf{Отсутствует} (Pure Dijkstra / A*) & Работает напрямую с топологией в таблицах PostGIS. Веса вычисляются SQL-запросом "на лету" \cite{crunchydata2026routing}. & Линейная зависимость времени поиска от размера графа. Требует мощного I/O. \\ \hline
    \end{tabular}
\end{table}

Как видно из анализа, все In-Memory решения (OSRM, GraphHopper, Valhalla) жертвуют возможностью мгновенного изменения весов ради производительности. Даже Valhalla, несмотря на название "Dynamic Costing", требует периодической пересборки тайлов для обновления данных трафика: \textit{"you would need to periodically update your tileset and restart your routing service to make the changes live"} \cite{valhalla_issue4030}. Это делает их непригодными для задач мультиагентной навигации, где веса ребер должны обновляться в реальном времени по мере движения агентов.

pgRouting, в свою очередь, обеспечивает атомарное изменение весов через стандартные SQL-операции (\texttt{UPDATE}), что критически важно для реализации динамической маршрутизации в условиях меняющегося трафика.

\section{Архитектура программного комплекса}

Система спроектирована по принципам сервис-ориентированной архитектуры (SOA), как показано на рисунке \ref{fig:system-arch}. Взаимодействие компонентов организовано следующим образом:
\begin{enumerate}
    \item \textbf{API Gateway} принимает запросы клиентов и маршрутизирует их.
    \item \textbf{Router Service} выполняет SQL-запросы к базе данных для построения маршрутов.
    \item \textbf{Database (PostgreSQL)} хранит топологию графа и вычисляет пути.
\end{enumerate}

\begin{figure}[H]
    \centering
    \include{assets/diagrams/01-system-arch}
    \caption{Архитектура системы: взаимодействие компонентов через шлюз и очередь сообщений}
    \label{fig:system-arch}
\end{figure}
