\section{Программная реализация подсистемы маршрутизации}

Подсистема маршрутизации (Router Service) реализует высокопроизводительный поиск пути, используя возможности расширения \texttt{pgRouting} и асинхронный драйвер \texttt{asyncpg}, реализующий бинарный протокол PostgreSQL \cite{habr2016asyncpg}.

\subsection{Конвейер обработки запроса маршрутизации}

Процесс обработки запроса на построение маршрута представлен на рисунке \ref{fig:runtime-flow}.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.75\textheight, keepaspectratio]{03-runtime-flow}
    \caption{Конвейер обработки запроса маршрутизации}
    \label{fig:runtime-flow}
\end{figure}

Алгоритм включает 4 этапа, реализованных на уровне SQL для минимизации передачи данных между БД и приложением.

\textbf{Этап 1: Интеллектуальная привязка к ребру.}
Для поиска ближайшего ребра графа используется оператор KNN (k-nearest neighbors) индекса GiST (\texttt{<->}) \cite{vonng2018knn, lyashenko2019postgis}, что значительно эффективнее стандартного поиска по дистанции (листинг \ref{lst:smart-snapping}).

\begin{code}{smart-snapping}{SQL}{Поиск ближайшего ребра}
ORDER BY geometry <-> ST_SetSRID(ST_MakePoint($1, $2), 4326)
LIMIT 1
\end{code}

\textbf{Этап 2: Динамическая область поиска.}
Реализация эвристики (\ref{eq:dynamic-bbox}), описанной в первой главе, выполнена на уровне SQL-запроса (листинг \ref{lst:dynamic-bbox-sql}).

\begin{code}{dynamic-bbox-sql}{SQL}{Расчет динамического BBox (pgrouting\_engine.py)}
SELECT ST_Expand(
    ST_Envelope(ST_MakeLine(start_n.geom, end_n.geom)), 
    -- Минимальный буфер 0.015 град., иначе 30% от дистанции
    GREATEST(0.015, ST_Distance(start_n.geom, end_n.geom) * 0.3)
)
\end{code}

Данная оптимизация ускоряет работу алгоритма Дейкстры в 5-10 раз \cite{zhou2017bounding} за счет исключения из графа заведомо нерелевантных ребер.

\textbf{Этап 3: Метод итеративных штрафов.}
Поиск альтернативных маршрутов ($K$-путей) реализован через динамическую модификацию весов \cite{akgun2012penalty}. В SQL-запрос передается массив исключений (параметр \texttt{\$3}), и стоимость прохода по этим ребрам увеличивается (листинг \ref{lst:penalty-sql}). В качестве штрафующего коэффициента был выбран пятикратный множитель, что позволило получать кардинально отличающиеся маршруты \cite{schmidt2023kshortestpaths} (см. раздел \ref{sec:quality}).

\begin{code}{penalty-sql}{SQL}{Динамическое пенализирование ребер}
CASE 
    -- Увеличение стоимости в 5 раз для уже использованных ребер
    WHEN id = ANY($3::bigint[]) THEN cost * 5.0 
    ELSE cost 
END as cost
\end{code}

\textbf{Этап 4: Коррекция ориентации геометрии.}
Поскольку граф \texttt{pgRouting} является ориентированным, а геометрия в базе хранится в фиксированном направлении, при проходе ребра в обратную сторону возникают визуальные артефакты (разрывы линий, <<зигзаги>> или <<галстуки>>). Для устранения этого применяется функция \texttt{ST\_Reverse} на основе проверки направления обхода (листинг \ref{lst:st-reverse-sql}).
    
\begin{code}{st-reverse-sql}{SQL}{Коррекция направления геометрии}
ST_AsBinary(
    CASE 
        WHEN op.node = e.source_id THEN e.geometry
        ELSE ST_Reverse(e.geometry) -- Разворот геометрии
    END
)
\end{code}
