\section{Программная реализация подсистемы маршрутизации}

Подсистема маршрутизации (Router Service) является вычислительным ядром комплекса, ответственным за построение графа дорожной сети и поиск оптимальных путей \cite{github_pgrouting}. Сервис реализован на языке Python с использованием фреймворка FastAPI, обеспечивающего высокую производительность за счет асинхронной обработки I/O операций.

\subsection{Предотвращение ложных топологических пересечений (Layer Separation)}

\paragraph{Проблема.}
Стандартный алгоритм построения топологии (\texttt{ST\_Node}) обрабатывает геометрии в двумерном пространстве. Если подать на вход все дорожные линии без предварительной обработки, система создаст узлы (перекрестки) в точках визуального пересечения дорог, проходящих на разных уровнях (например, мост над шоссе или тоннель под рекой). Это приводит к созданию некорректного маршрутного графа, где агент может совершить поворот с эстакады прямо на перпендикулярную улицу внизу.

\paragraph{Реализация.}
Для решения этой проблемы реализован конвейер предварительной обработки (см. рис. \ref{fig:build-flow}), включающий этап разделения слоев.
Перед построением топологии дороги жестко разделяются на две группы:
\begin{enumerate}
    \item \textbf{Ground Layer}: дороги, лежащие на земле (layer=0 или NULL).
    \item \textbf{Isolated Layer}: дороги, находящиеся на мостах (bridge=yes, layer>=1) или в тоннелях (tunnel=yes, layer<0).
\end{enumerate}

Алгоритм \texttt{pgr\_nodeNetwork} запускается независимо для каждой группы. Для изолированного слоя шаг поиска пересечений пропускается, либо выполняется только между объектами с одинаковым значением тега \texttt{layer}.
Это гарантирует корректность графа на многоуровневых развязках, таких как Третье транспортное кольцо (ТТК) в Москве.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.45\textheight, keepaspectratio]{03-build-flow}
    \caption{Пайплайн построения топологии графа с разделением слоев}
    \label{fig:build-flow}
\end{figure}

\subsection{Многопоточная сборка графа и алгоритм Grid Partitioning}

\paragraph{Проблема.}
Построение единого связного графа на территорию Московской агломерации (более 2.5 млн ребер) является вычислительно сложной задачей. При последовательной обработке (Single-threaded) время построения топологии составляло более 40 минут. Кроме того, загрузка всего графа в оперативную память приводила к исчерпанию ресурсов (OOM Killer) на узлах с 8 ГБ RAM.

\paragraph{Реализация.}
Для ускорения процесса применен метод параллельной обработки с использованием пула процессов (\texttt{multiprocessing.Pool}). Алгоритм разбиения на сетку (Grid Partitioning), описанный во второй главе, позволяет обрабатывать отдельные тайлы независимо друг от друга \cite{dagstuhl_edge_hierarchies_2019}.

Процесс сборки реализован следующим образом:
\begin{enumerate}
    \item Глобальная область (Bounding Box) делится на $N \times M$ секторов.
    \item Главный процесс-координатор распределяет задачи по построению подграфов между воркерами.
    \item Каждый воркер загружает данные своего сектора из PostGIS, строит локальную топологию и возвращает список граничных узлов.
    \item Координатор «сшивает» (Merge) результаты, объединяя дублирующиеся узлы на границах секторов.
\end{enumerate}

\paragraph{Преимущество.}
Распараллеливание задачи на 8 ядер CPU позволило сократить время сборки графа с 40 до 13 минут. Потребление оперативной памяти снизилось с 12 ГБ (при монолитной сборке) до 370 МБ на один процесс, что сделало возможным развертывание системы на стандартном оборудовании.

\subsection{Оптимизация взаимодействия с базой данных}

\paragraph{Проблема.}
При высокой нагрузке (сотни запросов в секунду) затраты на установку TCP-соединения с базой данных становятся существенными. Стандартные синхронные драйверы (psycopg2) блокируют поток выполнения на время ожидания ответа от СУБД, что снижает пропускную способность сервиса (Throughput).

\paragraph{Реализация.}
В качестве драйвера базы данных выбран \texttt{asyncpg}, реализующий бинарный протокол PostgreSQL и полную поддержку цикла событий \texttt{asyncio}.
Реализован механизм постоянного пула соединений (Connection Pool). Пул инициализируется при старте приложения и поддерживает открытыми от 10 до 50 соединений.
Настройка пула:
\begin{code}{asyncpg-pool}{Python}{Инициализация пула соединений asyncpg}
pool = await asyncpg.create_pool(
    dsn=database_url,
    min_size=10,
    max_size=50,
    command_timeout=60,
    statement_cache_size=0  # Отключено для экономии памяти
)
\end{code}

\paragraph{Преимущество.}
Использование пула соединений устранило накладные расходы на рукопожатие (Handshake) при каждом запросе. Бенчмарки показали, что переход на \texttt{asyncpg} увеличил пропускную способность сервиса в 3.5 раза по сравнению с синхронной реализацией на SQLAlchemy ORM.

\subsection{Оптимизация сериализации геометрии (WKB vs WKT)}

\paragraph{Проблема.}
Передача геометрии маршрута от базы данных к сервису в текстовом формате WKT (Well-Known Text) создает избыточную нагрузку на канал связи и процессор, требуя парсинга длинных строк вида \texttt{"LINESTRING(37.61 55.75, ...)"}. Для сложных маршрутов объем текстовых данных достигал нескольких мегабайт.

\paragraph{Реализация.}
Взаимодействие переведено на бинарный формат WKB (Well-Known Binary). Функция PostGIS \texttt{ST\_AsBinary} возвращает компактное байтовое преставление геометрии, которое напрямую десериализуется в объекты Python \texttt{shapely.geometry} или передается клиенту без декодирования \cite{postgis_asmvtgeom, postgis_wms_utwente}.

Сравнение объемов данных для маршрута длиной 25 км:
\begin{itemize}
    \item \textbf{WKT (Text):} 485 КБ. Парсинг: 120 мс.
    \item \textbf{WKB (Binary):} 142 КБ. Парсинг: 15 мс.
\end{itemize}

\paragraph{Преимущество.}
Переход на бинарный формат сократил объем передаваемого трафика в 3.4 раза и ускорил обработку ответов базы данных на порядок. Это критически важно для соблюдения SLA по времени построения маршрута (< 200 мс на сам поиск, < 50 мс на передачу).

\subsection{Конвейер обработки запроса маршрутизации}

Жизненный цикл запроса на построение маршрута включает в себя несколько этапов валидации и предварительной обработки входных данных. На рисунке \ref{fig:runtime-flow} показана последовательность действий системы от получения REST-запроса до возврата GeoJSON/WKB ответа.

\begin{figure}[H]
    \centering
    \includemermaid[width=\linewidth, height=0.5\textheight, keepaspectratio]{03-runtime-flow}
    \caption{Конвейер обработки запроса маршрутизации}
    \label{fig:runtime-flow}
\end{figure}

Ключевые этапы конвейера:
\begin{enumerate}
    \item \textbf{Smart Snapping (KNN).} Входные координаты (широта/долгота) привязываются к ближайшему ребру дорожного графа с использованием индекса GiST (оператор \texttt{<->}) \cite{postgis_vision_2018}.
    \item \textbf{Dynamic BBOX.} Для оптимизации поиска вычисляется ограничивающий прямоугольник, охватывающий старт и финиш, с динамическим отступом $\delta$.
    \item \textbf{SQL Routing.} Выполняется функция \texttt{pgr\_dijkstra} внутри базы данных.
    \item \textbf{Geometry Merge.} Найденные сегменты объединяются в единую линию \texttt{ST\_MakeLine}, и, при необходимости, к маршруту добавляются "хвосты" от реальных координат пользователя до узлов графа (Zig-Zag Fix).
\end{enumerate}
