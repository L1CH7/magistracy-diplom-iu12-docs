\chapter{Анализ предметной области и проектирование архитектуры}

\section{Анализ задачи маршрутизации в динамической среде}

Задача поиска оптимального маршрута в транспортной сети сводится к нахождению кратчайшего пути во взвешенном ориентированном графе $G = (V, E)$, где $V$ -- множество вершин (перекрестков, развязок), а $E$ -- множество ребер (дорожных участков). Каждому ребру $e \in E$ сопоставлен вес $w(e)$, отражающий стоимость прохождения данного участка (длину, время проезда или другой критерий).

В классической постановке задачи веса $w(e)$ считаются постоянными. Для статичных графов существуют высокоэффективные алгоритмы предварительной обработки, такие как Contraction Hierarchies (CH)\cite{geisberger2008_researchgate}. Суть метода CH заключается в построении иерархии вершин и добавлении «сокращений» (shortcuts) -- ребер, соединяющих удаленные узлы, минуя промежуточные. Это позволяет сократить пространство поиска с миллионов ребер до тысяч и достичь времени построения маршрута порядка 10 миллисекунд.

Однако в условиях городской среды веса ребер подвержены постоянным изменениям. Причинами могут служить дорожно-транспортные происшествия, ремонтные работы, введение временных ограничений или изменение погодных условий. В динамическом графе $G_t = (V, E, w_t)$ вес ребра является функцией времени $w(e, t)$. Использование статических иерархий в таких условиях становится неэффективным: изменение веса даже одного ребра может потребовать полной перестройки иерархии, что для графа крупного мегаполиса (например, Москвы) занимает от 30 до 60 минут вычислительного времени\cite{arxiv_parallel_ch_2024}. Такая задержка неприемлема для оперативного управления логистикой мультиагентных систем\cite{zhang2022novel}.

\section{Обзор существующих решений}

Для выбора оптимальной технологической платформы был проведен сравнительный анализ существующих систем маршрутизации с открытым исходным кодом: OSRM, Valhalla и GraphHopper.

\textbf{Open Source Routing Machine (OSRM)} -- высокопроизводительный движок маршрутизации, написанный на C++. OSRM использует алгоритм Contraction Hierarchies, обеспечивая экстремально высокую скорость запросов. Однако архитектура OSRM жестко ориентирована на статичность данных. Любое изменение графа требует перезапуска процесса предобработки (pre-processing), что исключает возможность учета динамических изменений в реальном времени.

\textbf{Valhalla} -- движок маршрутизации, использующий тайловую структуру хранения графа. Это позволяет обновлять отдельные фрагменты графа, однако механизм динамического изменения весов ("Dynamic Costing") ограничен заранее определенными параметрами и не позволяет произвольно исключать ребра из графа без перестройки тайлов.

\textbf{GraphHopper} -- решение на базе Java, поддерживающее как Contraction Hierarchies, так и более гибкий алгоритм A* (A-Star) на графе Landmarks. Несмотря на наличие механизмов гибкой настройки (Flexible Mode), потребление оперативной памяти (Java Heap) для графа масштаба страны может достигать десятков гигабайт, что усложняет эксплуатацию.

Сравнительные характеристики рассмотренных систем приведены в таблице~\ref{tab:routing-engines}.

\begin{table}[h]
    \caption{Сравнение технологий маршрутизации}
    \label{tab:routing-engines}
    \begin{tabular}{|p{0.2\textwidth}|p{0.2\textwidth}|p{0.2\textwidth}|p{0.25\textwidth}|}
    \hline
    \textbf{Критерий} & \textbf{OSRM} & \textbf{GraphHopper} & \textbf{Наше решение (pgRouting)} \\ \hline
    Архитектура & In-Memory (C++) & In-Memory (Java) & Database-Centric (PostgreSQL) \\ \hline
    Алгоритм & Contraction Hierarchies & CH / Landmarks & Dijkstra / A* (SQL) \\ \hline
    Время перестройки графа & 30-60 мин (Москва) & 15-30 мин & \textbf{0 мин (мгновенно)} \\ \hline
    Динамические веса & Нет & Частично & \textbf{Полная поддержка} \\ \hline
    Средняя латентность & $< 10$ мс & $20-50$ мс & $2.5 - 6$ с \\ \hline
    Требования к RAM & 4-8 ГБ & 6-12 ГБ & 370~МБ (shared buffers) \\ \hline
    \end{tabular}
\end{table}

Анализ показывает, что существующие решения оптимизированы для скорости построения маршрута в ущерб гибкости обновления данных. Для задач мультиагентной навигации, где критически важна возможность мгновенного изменения весов (например, закрытие зоны для проезда), использование OSRM требует создания множества изолированных инстансов, что экономически нецелесообразно.

\section{Обоснование выбора архитектуры Database-Centric}

На основе проведенного анализа было принято решение использовать подход \textit{Database-Centric}, при котором граф дорог хранится и обрабатывается непосредственно в реляционной базе данных PostgreSQL с расширением pgRouting. Данный подход обладает следующими преимуществами:

\begin{enumerate}
    \item \textbf{Нулевое время перестройки.} Вес ребра хранится в колонке таблицы. Изменение дорожной ситуации сводится к стандартной SQL-операции \texttt{UPDATE}, которая выполняется за миллисекунды и мгновенно учитывается при следующем поиске маршрута.
    \item \textbf{Транзакционная целостность.} Использование механизмов ACID гарантирует, что маршрут будет построен на основе согласованного состояния графа, даже если обновления происходят параллельно с чтением.
    \item \textbf{Богатые возможности фильтрации.} Язык SQL позволяет формулировать сложные критерии поиска (например, «избегать дорог с уклоном более 5 градусов», «использовать только освещенные улицы»), используя стандартные операторы \texttt{WHERE} и \texttt{JOIN}.
    \item \textbf{Экономия оперативной памяти.} В отличие от In-Memory решений, загружающих весь граф в память, PostgreSQL использует механизм \texttt{shared buffers}, подгружая с диска только востребованные страницы данных. Эксперименты показали потребление памяти порядка 370~МБ против 8 ГБ у OSRM для аналогичного графа.
\end{enumerate}

Платой за гибкость является увеличение латентности запроса до единиц секунд, что, однако, является допустимым компромиссом для систем планирования логистики, работающих не в режиме реального времени (soft real-time).

\section{Проектирование микросервисной архитектуры}

Система спроектирована в соответствии с принципами сервис-ориентированной архитектуры (SOA). Основными компонентами являются:

\begin{enumerate}
    \item \textbf{API Gateway (Шлюз).} Единая точка входа для всех клиентских запросов. Скрывает внутреннюю топологию системы и обеспечивает маршрутизацию запросов к соответствующим сервисам (Router или Data Processor). Это позволяет изменять внутреннюю структуру системы без влияния на клиентские приложения.
    \item \textbf{Router Service (Маршрутизатор).} Отвечает за выполнение графовых алгоритмов. Взаимодействует с базой данных PostgreSQL через асинхронный драйвер \texttt{asyncpg}, передавая SQL-запросы к расширению pgRouting.
    \item \textbf{Data Processor Service (Обработчик данных).} Осуществляет загрузку данных из OpenStreetMap\cite{dlr_osm_deep_dive_2024} через Overpass API и генерацию векторных тайлов (MVT) для визуализации.
    \item \textbf{PostgreSQL + PostGIS + pgRouting.} Единое хранилище геопространственных данных и графовой топологии.
    \item \textbf{Qt Client.} Кроссплатформенное клиентское приложение для визуализации карты и взаимодействия с пользователем.
\end{enumerate}

Схема взаимодействия компонентов представлена на рисунке~\ref{fig:system-arch}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth, height=0.55\textheight, keepaspectratio]{assets/diagrams/01-system-arch}
    \caption{Архитектура системы: взаимодействие компонентов через шлюз и очередь сообщений}
    \label{fig:system-arch}
\end{figure}

\section{Выбор технологий реализации}

\subsection{Стек базы данных: PostgreSQL и PostGIS}
Выбор PostgreSQL версии 15 обоснован наличием расширения PostGIS\cite{postgis_vision_2018}, которое является де-факто стандартом для работы с геоданными в открытом ПО. PostGIS предоставляет эффективные пространственные индексы (R-Tree / GiST), необходимые для быстрого поиска ближайших ребер графа (операция Snap-to-Road).

Особое внимание было уделено выбору метода генерации векторных тайлов (MVT). Рассматривались два подхода:
\begin{enumerate}
    \item \textbf{Статическая генерация (Pre-generated Tiles).} Использование утилит типа \textit{Tippecanoe} для создания набора статических файлов `.mvt` или `.mbtiles`. Данный подход обеспечивает максимальную скорость отдачи тайлов (менее 10 мс), но требует полной перегенерации всего набора тайлов при любом изменении данных или стиля отображения (например, скрытие определенных классов дорог).
    \item \textbf{Динамическая генерация (On-Demand).} Генерация тайлов «на лету» с помощью функции \texttt{ST\_AsMVT} непосредственно в базе данных.
\end{enumerate}

Для решения задачи динамической фильтрации объектов (LOD) без остановки сервиса был выбран подход \textbf{On-Demand}. Несмотря на бо́льшую задержку генерации (50-200 мс), он позволяет клиенту запрашивать тайлы с произвольными параметрами фильтрации, не требуя хранения терабайтов дублирующихся данных для разных стилей отображения.

\subsection{Язык программирования: Python и FastAPI}
Для реализации микросервисов выбран язык Python 3.11 и фреймворк FastAPI. Асинхронная модель ввода-вывода (AsyncIO), используемая в FastAPI, идеально подходит для I/O-bound задач, характерных для данной системы (ожидание ответов от базы данных и внешних API). В качестве драйвера базы данных используется \texttt{asyncpg}, который демонстрирует производительность, сопоставимую с решениями на Go и Rust, за счет использования бинарного протокола PostgreSQL и отсутствия накладных расходов на создание объектов Python для каждой строки результата.

\subsection{Клиентское приложение: Qt и MapLibre}
Для обеспечения кроссплатформенности и высокой производительности интерфейса выбран фреймворк Qt 6 (PyQt6). Для отображения карты используется библиотека MapLibre GL JS\cite{maplibre_main}, интегрируемая в окно Qt через компонент \texttt{QWebEngineView}. Такое решение (гибридная архитектура) позволяет использовать всю мощь WebGL для рендеринга векторной карты, сохраняя при этом возможности десктопного приложения (доступ к файловой системе, системные диалоги).

\section{Выводы по первой главе}

В данной главе проведен анализ предметной области и существующих решений для навигации. Выявлено, что популярные системы (OSRM, GraphHopper) не обеспечивают требуемой гибкости для динамического изменения весов графа в реальном времени. Обоснован выбор архитектуры \textit{Database-Centric} на базе PostgreSQL и pgRouting, которая, несмотря на большую латентность, предоставляет необходимые возможности для реализации адаптивной маршрутизации. Спроектирована микросервисная архитектура системы, обеспечивающая масштабируемость и разделение ответственности между модулями.
