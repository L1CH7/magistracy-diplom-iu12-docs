\chapter{Исследовательский раздел}
\label{ch:analysis}

\section{Анализ предметной области и постановка задачи}

Современные навигационные системы мультиагентного типа предъявляют высокие требования к гибкости маршрутизации, качеству визуализации и масштабируемости архитектуры. В условиях растущей нагрузки и необходимости обработки данных в реальном времени, традиционные монолитные архитектуры демонстрируют ряд существенных ограничений. В частности, они обладают низкой отказоустойчивостью и сложностью в обновлении отдельных компонентов без остановки всей системы. В рамках данной работы рассматривается проектирование распределенной системы, в которой ключевым архитектурным паттерном является API Gateway, выполняющий функцию единой точки входа (Single Entry Point).

Архитектура системы построена по принципу микросервисов, где каждый компонент отвечает за изолированную область бизнес-логики. Такое разделение позволяет использовать различные технологические стеки, оптимально подходящие для конкретных задач, а также независимо масштабировать сервисы в зависимости от нагрузки.

Система состоит из следующих основных компонентов:
\begin{itemize}
    \item \textbf{Сервис маршрутизации (Router Service)} --- модуль, обеспечивающий вычисление оптимальных маршрутов и управление дорожным графом. Он отвечает за алгоритмическую часть поиска пути.
    \item \textbf{Сервис обработки данных (Data Processor Service)} --- компонент, осуществляющий взаимодействие с внешними источниками геоданных, в частности OpenStreetMap (OSM), и генерацию векторных тайлов (MVT) в режиме реального времени.
    \item \textbf{Клиентское приложение (Qt Client)} --- интерфейс пользователя, реализованный на базе фреймворка Qt, обеспечивающий визуализацию картографической информации и взаимодействие с системой.
\end{itemize}

Общая схема архитектуры системы представлена на рисунке~\ref{fig:system-arch}.

\begin{figure}[H]
    \centering
    \includemermaid[width=0.55\linewidth]{01-system-arch}
    \caption{Схема архитектуры системы (C4 Context)}
    \label{fig:system-arch}
\end{figure}

Использование паттерна Gateway позволяет скрыть внутреннюю топологию сети от клиента, предоставляя единый унифицированный интерфейс API. Взаимодействие осуществляется исключительно через шлюз, который маршрутизирует запросы к соответствующим внутренним сервисам (upstream). Данный подход обеспечивает изоляцию внутренних компонентов --- клиент не имеет прямого доступа к сервисам маршрутизации или обработки данных, что повышает безопасность системы. Кроме того, это упрощает клиентскую логику, так как клиенту не нужно знать адреса и протоколы взаимодействия с каждым отдельным сервисом, и обеспечивает возможность горизонтального масштабирования инфраструктуры.

В классических реализациях микросервисных шлюзов часто встречается проблема жестко заданных маршрутов (Hardcoded Routes). При таком подходе правила маршрутизации фиксируются непосредственно в исходном коде программного обеспечения. Конфигурация оказывается распределенной по различным модулям, а добавление нового микросервиса требует изменения логики шлюза, перекомпиляции и повторного развертывания. Это существенно замедляет процесс разработки и внедрения новых функций.

Для обеспечения эксплуатационной гибкости и устранения недостатков жесткой конфигурации, к инфраструктуре предъявляются следующие требования:
\begin{enumerate}
    \item \textbf{Принцип DRY (Don't Repeat Yourself).} Логика проксирования должна быть универсальной и не зависеть от специфики конкретного сервиса.
    \item \textbf{Декларативность.} Маршруты должны описываться в конфигурационных файлах (в формате YAML), а не в программном коде. Это позволяет изменять топологию системы без пересборки приложения.
    \item \textbf{Производительность.} Накладные расходы (overhead) на проксирование запросов не должны оказывать существенного влияния на общее время отклика системы и не должны превышать 10 мс.
\end{enumerate}

\section{Сравнительный анализ технологий маршрутизации}

Ключевой функциональной задачей разрабатываемой системы является поиск оптимального пути по дорожному графу. Для масштабов крупной агломерации, такой как Москва, граф содержит более 250 000 ребер. Специфическим требованием, отличающим данную систему от классических навигаторов, выступает возможность динамического изменения весов ребер. Это необходимо для учета перекрытий дорог, изменения дорожной обстановки или введения ограничений для спецтранспорта в режиме реального времени без необходимости полной перестройки графа.

Существующие индустриальные стандарты, такие как OSRM (Open Source Routing Machine), Valhalla и GraphHopper, достигают субсекундной задержки (менее 10 мс) за счет использования алгоритмов на базе иерархий сжатия (Contraction Hierarchies --- CH).

Стоит отметить, что первоначальные попытки использования классического алгоритма A* (A-Star) на базе реляционной СУБД показали неудовлетворительные результаты. Основной причиной стала не вычислительная сложность самого алгоритма, а накладные расходы на извлечение данных. Хранение графа в нормализованной форме (таблицы `nodes` и `edges`) требует выполнения операции `JOIN` для получения координат каждой вершины в процессе обхода. При длине маршрута в 1000 ребер это приводит к тысячам дисковых операций чтения (Random Seek), что увеличивает время поиска до 30--40 секунд даже при наличии индексов.

Метод CH, напротив, заключается в предварительной обработке графа и создании дополнительных <<ярлыков>> (shortcuts) между узлами, которые позволяют пропускать множество промежуточных вершин при поиске пути. Данный подход обеспечивает высокую скорость поиска в статичном графе.

Однако критическим ограничением метода Contraction Hierarchies является его статичность. Изменение веса даже одного ребра нарушает целостность иерархии ярлыков и требует полной перестройки индексов. Для графа масштаба Москвы данный процесс занимает от 30 до 60 минут процессорного времени. Это делает невозможным учет динамических факторов в режиме реального времени, так как за время перестройки графа дорожная ситуация может измениться вновь.

Сравнение существующих технологий маршрутизации по ключевым критериям приведено в таблице~\ref{tab:routing-comparison}.

\begin{table}[H]
    \centering
    \caption{Сравнение технологий маршрутизации}
    \label{tab:routing-comparison}
    \begin{tabular}{|p{0.22\linewidth}|p{0.18\linewidth}|p{0.18\linewidth}|p{0.18\linewidth}|p{0.14\linewidth}|}
        \hline
        \textbf{Критерий} & \textbf{OSM} & \textbf{Valhalla} & \textbf{GraphHopper} & \textbf{pgRouting} \\ \hline
        Архитектура хранения & In-Memory (RAM) & MMap Tiles & In-Memory (JVM) & PostgreSQL (Disk) \\ \hline
        Предобработка & Contraction Hierarchies & Обязательна & CH / Landmarks & Нет \\ \hline
        Время перестройки & 30--60 мин & 20--40 мин & 15--30 мин & 0 мин \\ \hline
        Динамика весов & Невозможно & Ограничено & Невозможно & Мгновенно \\ \hline
        Средняя задержка & $< 10$ мс & 15--30 мс & 20--50 мс & 2500--6000 мс \\ \hline
        Потребление RAM & 4--8 ГБ & 2--4 ГБ & 6--12 ГБ & 370 МБ \\ \hline
    \end{tabular}
\end{table}

На основе проведенного анализа было принято решение использовать технологический стек \textbf{PostgreSQL + PostGIS + pgRouting}. Несмотря на более низкую производительность «чистого» поиска пути по сравнению с решениями In-Memory, данный выбор обусловлен следующими факторами, критичными для динамической системы:
\begin{itemize}
    \item \textbf{Отсутствие времени перестройки.} Веса ребер хранятся непосредственно в таблицах базы данных. Изменение веса ребра представляет собой стандартную SQL-транзакцию \texttt{UPDATE}, которая выполняется за миллисекунды и мгновенно учитывается при следующем поиске маршрута.
    \item \textbf{Гибкость логики.} Ограничения движения любой сложности (временные окна, типы транспортных средств, габариты) реализуются посредством изменения SQL-запросов, без необходимости модификации движка маршрутизации.
    \item \textbf{Эффективность использования памяти.} Граф хранится на диске, а в оперативной памяти (в области Shared Buffers) находятся только часто используемые участки данных ("горячие" данные). Это позволяет работать с огромными графами на оборудовании с ограниченным объемом RAM.
\end{itemize}

Компромиссом выбранного решения является увеличение времени поиска маршрута до единиц секунд, что допустимо для логистических задач планирования. Для обеспечения отзывчивости интерфейса данная задержка компенсируется реализацией асинхронного взаимодействия на стороне клиента.

\section{Архитектура подсистемы обработки геоданных}

Модуль обработки геоданных (Data Processor) решает комплекс задач, связанных с получением актуальной картографической информации. Основными функциями являются загрузка сырых данных из OpenStreetMap и генерация векторных тайлов (MVT --- Mapbox Vector Tiles) для отображения карты на клиенте. Обеспечение актуальности данных критически важно для корректной маршрутизации.

Визуализация векторных данных требует эффективной стратегии нарезки геометрии на тайлы. Существуют различные подходы к решению этой задачи, от полной предварительной генерации до формирования тайлов в момент запроса. Были рассмотрены основные стратегии, представленные в таблице~\ref{tab:tiles-comparison}.

\begin{table}[H]
    \centering
    \caption{Сравнение подходов к генерации векторных тайлов}
    \label{tab:tiles-comparison}
    \begin{tabular}{|p{0.3\linewidth}|p{0.3\linewidth}|p{0.3\linewidth}|}
        \hline
        \textbf{Подход} & \textbf{Преимущества} & \textbf{Недостатки} \\ \hline
        Статическая генерация (Tippecanoe) & Высокая скорость отдачи (раздача статичных файлов через Nginx/CDN) & Невозможность динамической смены стилей, длительный процесс полной пересборки при обновлении данных \\ \hline
        Сервер тайлов (Tileserver GL) & Готовое коробочное решение, простота развертывания & Жесткая привязка к формату MBTiles, сложность кастомизации логики \\ \hline
        Генерация по запросу (On-Demand: PostGIS + ST\_AsMVT) & Полный контроль логики через SQL, динамическая детализация (LOD), отсутствие дублирования данных & Повышенная нагрузка на БД, более низкая скорость ответа по сравнению со статикой \\ \hline
    \end{tabular}
\end{table}

В результате анализа был выбран подход \textbf{On-Demand Generation} (генерация по запросу). В данной архитектуре тайлы не хранятся на диске в виде файлов, а формируются динамически SQL-запросом с использованием функции \texttt{ST\_AsMVT} в момент обращения клиента. Это позволяет реализовать концепцию динамического уровня детализации (Level of Detail --- LOD): состав объектов в тайле (например, отображение дворовых проездов только на крупных масштабах или скрытие мелких деталей на обзорных картах) изменяется путем модификации параметров запроса. Такой подход исключает необходимость длительной перегенерации кэша при изменении стилей отображения или обновлении атрибутов дорог.

\section{Архитектура клиентского приложения}

Клиентское приложение является основным интерфейсом взаимодействия пользователя с системой. Оно должно обеспечивать не только ввод пунктов назначения и просмотр маршрутов, но и качественную, плавную визуализацию карты с высокой частотой кадров (60 FPS), поддерживая при этом интерактивность.

Для реализации клиента был выбран гибридный архитектурный подход, объединяющий возможности нативного фреймворка \textbf{PyQt5} и современного веб-движка для карт \textbf{MapLibre GL JS}. Сравнение рассмотренных вариантов реализации приведено в таблице~\ref{tab:client-arch}.

\begin{table}[H]
    \centering
    \caption{Сравнение подходов к реализации клиента}
    \label{tab:client-arch}
    \begin{tabular}{|p{0.3\linewidth}|p{0.3\linewidth}|p{0.3\linewidth}|}
        \hline
        \textbf{Подход} & \textbf{Преимущества} & \textbf{Недостатки} \\ \hline
        Нативный Qt (QGraphicsView) & Высокая производительность C++, полный контроль над управлением памятью & Отсутствие встроенной поддержки формата MVT, высокая трудоемкость реализации стилизации карт \\ \hline
        Web-приложение (React/Vue) & Простая разработка UI, богатая экосистема картографических библиотек & Ограничения браузерной песочницы (доступ к локальным файлам, оборудованию), зависимость от браузера \\ \hline
        Гибридное приложение (Qt + WebView) & Баланс производительности GPU (WebGL через WebView) и возможностей Desktop-приложения & Накладные расходы памяти на запуск браузерного движка, сложность реализации моста JS-Python \\ \hline
    \end{tabular}
\end{table}

Архитектура клиентского приложения построена на строгом разделении ответственности между компонентами:
\begin{enumerate}
    \item \textbf{Слой Python (PyQt5)} управляет жизненным циклом приложения, потоками (QThread), сетевым взаимодействием и основной бизнес-логикой. Он отвечает за взаимодействие с сервером и обработку данных.
    \item \textbf{Слой JavaScript (MapLibre GL JS)}, работающий внутри компонента \texttt{QWebEngineView}, отвечает исключительно за рендеринг векторных тайлов с использованием WebGL. Это позволяет задействовать аппаратное ускорение графического процессора для плавной отрисовки карты.
    \item \textbf{Мост QWebChannel} обеспечивает двунаправленную асинхронную связь между средой Python и JavaScript, позволяя передавать команды управления картой и получать события от пользователя.
\end{enumerate}

Данный подход позволяет использовать современные стандарты веб-картографии (MVT, шейдеры WebGL) в рамках функционального десктопного приложения.
